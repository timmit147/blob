<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blob → Shape (command input)</title>

<style>
:root{
  --bg:#0b0f19;
  --fg:#e9eefc;
  --ui:rgba(255,255,255,.08);
  --ui-b:rgba(255,255,255,.14);
}
html,body{height:100%;margin:0}
body{
  background:radial-gradient(1200px 700px at 50% 40%,#151d33 0%,var(--bg) 60%,#070a12 100%);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--fg);
  overflow:hidden;
}

/* center stage */
.stage{
  position:fixed;
  inset:0;
  display:grid;
  place-items:center;
  pointer-events:none;
}
svg{
  width:min(520px,86vw);
  height:auto;
  filter:drop-shadow(0 18px 40px rgba(0,0,0,.55));
}

/* bottom input */
.bottom{
  position:fixed;
  left:50%;
  bottom:22px;
  transform:translateX(-50%);
  width:min(780px,92vw);
  pointer-events:auto;
}
.bottom input{
  width:100%;
  padding:14px 16px;
  border-radius:14px;
  border:1px solid var(--ui-b);
  background:var(--ui);
  color:var(--fg);
  outline:none;
  font-size:16px;
}

/* smooth changes */
#shapeGroup{
  transition: transform 320ms ease;
  transform-origin: 0px 0px;
}
svg path{
  transition: fill 280ms ease;
}
</style>
</head>

<body>

<div class="stage">
  <svg id="svgRoot" viewBox="-220 -220 440 440" xmlns="http://www.w3.org/2000/svg">
    <g id="shapeGroup"></g>
    <path id="helperPath" fill="none" stroke="none" visibility="hidden"/>
  </svg>
</div>

<div class="bottom">
  <input id="cmd" placeholder='type shape name (e.g. "heart") — commands: copy | export | rotate 180 | #86c5e4 | red'/>
</div>

<script>
(() => {
  const TAU = Math.PI * 2;
  const lerp = (a,b,t)=>a+(b-a)*t;

  const POINTS = 140;     // smoother & rounder
  const BASE_R = 140;

  const group  = document.getElementById("shapeGroup");
  const helper = document.getElementById("helperPath");
  const cmd    = document.getElementById("cmd");

  let fillColor = "#ffffff";
  let rotationDeg = 0;

  // blob | shape
  let mode = "blob";
  let multiShape = false;       // multi-path => poly rendering to prevent “bridging”
  let raf = null, last = performance.now(), time = 0;

  // Multi-path state: arrays of point arrays
  let currentSets = [makeBlobPoints()];
  let targetSets  = [makeBlobPoints()];

  // ===== Satisfying, rounder blob =====
  // (smaller amplitudes + breathing = less “ugly spikes”)
  const blobPhase = Array.from({length: POINTS}, (_, i) => {
    const th = (i / POINTS) * TAU;
    return 2.6*Math.sin(th*2.2 + 0.9) + 1.7*Math.sin(th*1.2 - 0.4);
  });

  function makeBlobPoints(){
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const th=(i/POINTS)*TAU;

      // rounder base (reduced deformation)
      const base =
        1
        + 0.08*Math.sin(th*2 + 0.6)
        + 0.05*Math.sin(th*3 - 1.2)
        + 0.03*Math.sin(th*5 + 2.1);

      const r = BASE_R * base;

      pts.push({x:r*Math.cos(th), y:r*Math.sin(th)});
    }
    return pts;
  }

  // ===== Path building =====
  // Smooth (nice for single)
  function toSmoothPath(pts){
    const n = pts.length;
    const p = (i)=>pts[(i+n)%n];
    let d="";
    for(let i=0;i<n;i++){
      const p0=p(i-1), p1=p(i), p2=p(i+1), p3=p(i+2);
      const c1x = p1.x + (p2.x - p0.x)/6;
      const c1y = p1.y + (p2.y - p0.y)/6;
      const c2x = p2.x - (p3.x - p1.x)/6;
      const c2y = p2.y - (p3.y - p1.y)/6;
      if(i===0) d += `M ${p1.x.toFixed(2)} ${p1.y.toFixed(2)} `;
      d += `C ${c1x.toFixed(2)} ${c1y.toFixed(2)}, ${c2x.toFixed(2)} ${c2y.toFixed(2)}, ${p2.x.toFixed(2)} ${p2.y.toFixed(2)} `;
    }
    return d + "Z";
  }

  // Poly (prevents bulging/bridging in multi-part icons)
  function toPolyPath(pts){
    let d = `M ${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)} `;
    for(let i=1;i<pts.length;i++){
      d += `L ${pts[i].x.toFixed(2)} ${pts[i].y.toFixed(2)} `;
    }
    return d + "Z";
  }

  // ===== Normalization to prevent “shrink then morph” =====
  // We enforce:
  // 1) overall centroid at (0,0)
  // 2) overall max radius = BASE_R
  // This makes morphing look like true shape-to-shape, not shrink-expand.
  function stabilizeSizeAndCenter(sets){
    // centroid across ALL points
    let cx=0, cy=0, count=0;
    for(const pts of sets){
      for(const p of pts){ cx+=p.x; cy+=p.y; count++; }
    }
    cx/=count; cy/=count;

    // recenter
    for(const pts of sets){
      for(const p of pts){ p.x-=cx; p.y-=cy; }
    }

    // scale to fixed size
    let maxR=0;
    for(const pts of sets){
      for(const p of pts){ maxR=Math.max(maxR, Math.hypot(p.x,p.y)); }
    }
    const s = maxR > 0 ? (BASE_R / maxR) : 1;
    for(const pts of sets){
      for(const p of pts){ p.x*=s; p.y*=s; }
    }
  }

  function centroid(pts){
    let cx=0, cy=0;
    for(const p of pts){ cx+=p.x; cy+=p.y; }
    return {x:cx/pts.length, y:cy/pts.length};
  }

  // ===== Sampling SVG paths =====
  function pointsFromPathD(d){
    helper.setAttribute("d", d);
    const L = helper.getTotalLength();
    if(!isFinite(L) || L <= 0) return null;
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const p = helper.getPointAtLength((i/POINTS) * L);
      pts.push({x:p.x, y:p.y});
    }
    return pts;
  }

  // Normalize multi-path shape as a group (keep separation), then stabilize
  function normalizeLoadedSets(sets){
    // center & scale by overall bounds
    stabilizeSizeAndCenter(sets);

    // tiny per-piece shrink to avoid “edge kissing” (doesn't change gap noticeably)
    if(sets.length > 1){
      const shrink = 0.992;
      for(const pts of sets){
        const c = centroid(pts);
        for(const p of pts){
          p.x = c.x + (p.x - c.x) * shrink;
          p.y = c.y + (p.y - c.y) * shrink;
        }
      }
      stabilizeSizeAndCenter(sets);
    }
    return sets;
  }

  // ===== SVG DOM helpers =====
  function ensurePathEls(n){
    while(group.children.length < n){
      const p = document.createElementNS("http://www.w3.org/2000/svg","path");
      p.setAttribute("fill", fillColor);
      group.appendChild(p);
    }
    while(group.children.length > n){
      group.removeChild(group.lastChild);
    }
    for(const el of group.children){
      el.setAttribute("fill", fillColor);
    }
  }

  function setFill(c){
    fillColor = c;
    for(const el of group.children) el.setAttribute("fill", c);
  }

  function setRotation(newDeg){
    rotationDeg = newDeg;
    group.setAttribute("transform", `rotate(${rotationDeg})`);
  }

  // ===== Animation =====
  function start(){
    if(raf) cancelAnimationFrame(raf);
    last = performance.now();
    raf = requestAnimationFrame(tick);
  }

  function tick(now){
    const dt = (now-last)/1000;
    last = now;
    time += dt;

    const alpha = 1 - Math.exp(-2.7 * dt); // smooth morph
    let done = true;

    // morph
    for(let s=0; s<currentSets.length; s++){
      const a = currentSets[s];
      const b = targetSets[s];
      for(let i=0;i<POINTS;i++){
        const nx = lerp(a[i].x, b[i].x, alpha);
        const ny = lerp(a[i].y, b[i].y, alpha);
        if(Math.hypot(nx-b[i].x, ny-b[i].y) > 0.03) done = false;
        a[i].x = nx; a[i].y = ny;
      }
    }

    // KEY: stabilize size every frame to prevent shrink-expand
    stabilizeSizeAndCenter(currentSets);

    ensurePathEls(currentSets.length);

    // render
    for(let s=0; s<currentSets.length; s++){
      let renderPts = currentSets[s];

      if(mode === "blob"){
        // gentle breathing + round wobble
        const breathe = 1 + 0.02*Math.sin(time*1.1);

        renderPts = currentSets[s].map((p,i)=>{
          const r = Math.hypot(p.x,p.y);
          const th = Math.atan2(p.y,p.x);

          const wobble =
            1
            + 0.055*Math.sin(time*1.9 + blobPhase[i] + s*0.6)
            + 0.030*Math.sin(time*2.7 + blobPhase[i]*0.7 + s*0.35);

          const rr = r * wobble * breathe;
          return { x: rr*Math.cos(th), y: rr*Math.sin(th) };
        });
      }

      const d = (multiShape ? toPolyPath(renderPts) : toSmoothPath(renderPts));
      group.children[s].setAttribute("d", d);
    }

    if(mode === "shape" && done){
      raf = null; // freeze perfectly
      return;
    }
    raf = requestAnimationFrame(tick);
  }

  // ===== Hybrid local shapes loader =====
  const cache = {};
  async function loadShapeByName(name){
    const file = name.toLowerCase().trim().replace(/\s+/g,"-") + ".svg";
    if(cache[file]) return cache[file];

    try{
      const res = await fetch("shapes/" + file, {cache:"force-cache"});
      if(!res.ok) return null;
      const txt = await res.text();
      const doc = new DOMParser().parseFromString(txt, "image/svg+xml");
      const paths = [...doc.querySelectorAll("path")];
      if(!paths.length) return null;

      const sets = [];
      for(const p of paths){
        const d = p.getAttribute("d");
        if(!d) continue;
        const pts = pointsFromPathD(d);
        if(pts) sets.push(pts);
      }
      if(!sets.length) return null;

      cache[file] = normalizeLoadedSets(sets);
      return cache[file];
    } catch {
      return null;
    }
  }

  // Spawn blob sets matching target path count, positioned near each target centroid
  function spawnFromTargets(targetSetsIn){
    const spawned = targetSetsIn.map((tset)=>{
      const b = makeBlobPoints();
      const ct = centroid(tset);
      const cb = centroid(b);
      for(const p of b){
        p.x = (p.x - cb.x) + ct.x;
        p.y = (p.y - cb.y) + ct.y;
      }
      return b;
    });
    stabilizeSizeAndCenter(spawned);
    return spawned;
  }

  // ===== Command parsing =====
  function isCssColor(str){
    const s = str.trim();
    if(!s) return false;
    const test = document.createElement("div");
    test.style.color = "";
    test.style.color = s;
    return !!test.style.color;
  }

  function doCopy(){
    navigator.clipboard.writeText(exportSVGString());
  }

  function doExport(){
    const text = exportSVGString();
    const blob = new Blob([text], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "shape.svg";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function applyRotateDelta(delta){
    setRotation(rotationDeg + delta);
  }

  function exportSVGString(){
    const vb = "-220 -220 440 440";
    const ds = [...group.children].map(p => p.getAttribute("d") || "").filter(Boolean);
    const paths = ds.map(d => `    <path d="${d}" fill="${fillColor}"/>`).join("\n");
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}">
  <g transform="rotate(${rotationDeg})">
${paths}
  </g>
</svg>\n`;
  }

  // Debounce shape lookup to avoid fetch per keystroke
  let shapeTimer = null;
  let lastShapeQuery = "";

  async function tryLoadShape(query){
    const v = query.trim();
    if(!v) return;

    // if already active query, skip
    if(v === lastShapeQuery) return;

    const sets = await loadShapeByName(v);
    if(!sets) return;

    lastShapeQuery = v;
    mode = "shape";
    multiShape = (sets.length > 1);

    if(currentSets.length !== sets.length){
      currentSets = spawnFromTargets(sets);
    }
    targetSets = sets.map(pts => pts.map(p => ({x:p.x, y:p.y}))); // deep copy
    start();
  }

  // Execute “instant commands” when input becomes a full command
  function tryHandleCommandInstant(text){
    const raw = text.trim();
    if(!raw) return false;

    const lower = raw.toLowerCase();

    // copy
    if(lower === "copy"){
      doCopy();
      cmd.value = "";
      lastShapeQuery = "";
      // back to blob automatically by input handler
      return true;
    }

    // export
    if(lower === "export"){
      doExport();
      cmd.value = "";
      lastShapeQuery = "";
      return true;
    }

    // rotate N
    // examples: "rotate 180", "rotate -90"
    if(lower.startsWith("rotate ")){
      const n = parseFloat(raw.slice(7).trim());
      if(Number.isFinite(n)){
        applyRotateDelta(n);
        // keep the command visible briefly then clear
        cmd.value = "";
        return true;
      }
    }

    // color: hex or named or rgb/hsl
    if(isCssColor(raw)){
      setFill(raw);        // transitions via CSS
      cmd.value = "";
      return true;
    }

    return false;
  }

  // Input behavior:
  // - empty => blob mode
  // - if becomes a command => execute + clear
  // - otherwise debounce shape lookup
  cmd.addEventListener("input", () => {
    const v = cmd.value;

    // empty => blob mode
    if(v.trim() === ""){
      lastShapeQuery = "";
      mode = "blob";
      multiShape = false;

      currentSets = [makeBlobPoints()];
      targetSets  = [makeBlobPoints()];
      stabilizeSizeAndCenter(currentSets);
      stabilizeSizeAndCenter(targetSets);
      start();
      return;
    }

    // commands
    if(tryHandleCommandInstant(v)){
      // input cleared inside; triggering input event may happen next tick
      return;
    }

    // shapes: debounce
    clearTimeout(shapeTimer);
    shapeTimer = setTimeout(() => {
      tryLoadShape(v);
    }, 220);
  });

  // Optional: Enter forces shape lookup immediately (doesn't hurt auto-recognition)
  cmd.addEventListener("keydown", (e) => {
    if(e.key === "Enter"){
      const v = cmd.value;
      if(tryHandleCommandInstant(v)) return;
      tryLoadShape(v);
    }
  });

  // ===== Boot =====
  setFill("#ffffff");
  setRotation(0);
  stabilizeSizeAndCenter(currentSets);
  stabilizeSizeAndCenter(targetSets);
  start();
})();
</script>

</body>
</html>

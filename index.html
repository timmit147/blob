<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blob → Shape</title>

<style>
:root{
  --bg:#0b0f19;
  --fg:#e9eefc;
  --muted:rgba(233,238,252,.68);
  --ui:rgba(255,255,255,.08);
  --ui-b:rgba(255,255,255,.14);
}
html,body{height:100%;margin:0}
body{
  background:radial-gradient(1200px 700px at 50% 40%,#151d33 0%,var(--bg) 60%,#070a12 100%);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--fg);
  overflow:hidden;
}

/* center stage */
.stage{
  position:fixed;
  inset:0;
  display:grid;
  place-items:center;
  pointer-events:none;
}
svg{
  width:min(520px,86vw);
  height:auto;
  filter:drop-shadow(0 18px 40px rgba(0,0,0,.55));
}

/* bottom input */
.bottom{
  position:fixed;
  left:50%;
  bottom:22px;
  transform:translateX(-50%);
  width:min(780px,92vw);
  pointer-events:auto;
}
.bottom input{
  width:100%;
  padding:14px 16px;
  border-radius:14px;
  border:1px solid var(--ui-b);
  background:var(--ui);
  color:var(--fg);
  outline:none;
  font-size:16px;
}

/* smooth transform changes */
#shapeGroup{
  transition: transform 1800ms cubic-bezier(.2,.9,.2,1);
  transform-origin: 0px 0px;
}
svg path{
  transition: fill 600ms ease;
}

/* info button (requested: light gray bg, black icon) */
.infoBtn{
  position:fixed;
  top:14px;
  right:14px;
  width:38px;
  height:38px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.18);
  background:#d9d9d9;
  color:#000;
  display:grid;
  place-items:center;
  cursor:pointer;
  pointer-events:auto;
  font-weight:700;
}
.infoBtn:hover{background:#e6e6e6}

/* modal */
.modal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  display:none;
  align-items:center;
  justify-content:center;
  pointer-events:auto;
}
.modal.open{display:flex}
.card{
  width:min(780px,92vw);
  background:rgba(10,14,25,.95);
  border:1px solid var(--ui-b);
  border-radius:16px;
  padding:16px;
  box-shadow:0 18px 60px rgba(0,0,0,.6);
}
.card h3{margin:0 0 10px;font-size:16px}
.card p{margin:8px 0;color:var(--muted);font-size:14px;line-height:1.45}
.grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:12px;
  margin-top:12px;
}
.box{
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.05);
  border-radius:12px;
  padding:10px;
}
.box h4{margin:0 0 8px;font-size:14px;color:var(--fg)}
.list{
  margin:0;
  padding-left:18px;
  color:var(--muted);
  font-size:14px;
  line-height:1.45;
}
code{
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.12);
  padding:2px 6px;
  border-radius:8px;
  color:var(--fg);
  font-size:13px;
}
.actions{
  display:flex;
  justify-content:flex-end;
  margin-top:12px;
}
.btn{
  border:1px solid var(--ui-b);
  background:var(--ui);
  color:var(--fg);
  border-radius:12px;
  padding:10px 12px;
  font-size:14px;
  cursor:pointer;
}
.btn:hover{background:rgba(255,255,255,.12)}
</style>
</head>

<body>

<button class="infoBtn" id="infoBtn" aria-label="Info">i</button>

<div class="stage">
  <svg id="svgRoot" viewBox="-220 -220 440 440" xmlns="http://www.w3.org/2000/svg">
    <g id="shapeGroup"></g>
    <path id="helperPath" fill="none" stroke="none" visibility="hidden"/>
  </svg>
</div>

<div class="bottom">
  <input id="cmd" placeholder="type shape name" autocomplete="off" spellcheck="false"/>
</div>

<div class="modal" id="modal" role="dialog" aria-modal="true">
  <div class="card">
    <h3>Info</h3>
    <p>
      Type a shape name that exists in your <code>/shapes</code> folder (e.g. <code>heart</code>, <code>triangle</code>).
      Press <b>Enter</b> to run commands. Clearing the input returns to blob mode.
    </p>

    <div class="grid">
      <div class="box">
        <h4>Commands (press Enter)</h4>
        <ul class="list">
          <li><code>copy</code> — copy current SVG</li>
          <li><code>export</code> — download SVG</li>
          <li><code>random</code> — choose a random shape</li>
          <li><code>rotate 180</code> — rotate relative (slow & smooth)</li>
          <li><code>rotate -180</code> — rotate back</li>
          <li><code>red</code> / <code>#86c5e4</code> / <code>rgb(10,20,30)</code> — change color</li>
        </ul>
      </div>

      <div class="box">
        <h4>Shapes list (edit in code)</h4>
        <p style="margin:0 0 8px;color:var(--muted);font-size:13px">
          This list is shown here for convenience (browsers can’t auto-list your folder).
        </p>
        <ul class="list" id="shapeList"></ul>
      </div>
    </div>

    <div class="actions">
      <button class="btn" id="closeBtn">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  const TAU = Math.PI * 2;
  const lerp = (a,b,t)=>a+(b-a)*t;

  // ====== Edit this list to match what you put in /shapes ======
  const SHAPES = [
    "circle","oval","triangle","square","rectangle","diamond",
    "pentagon","hexagon","star","heart","lightning bolt",
    "plus","cross","check","close","menu","search","home","user",
    "play","pause","stop","download","upload","arrow up","arrow right","chevron",
    "capsule","drop","trapezoid","parallelogram","settings","notification"
  ];

  // More points => smoother blob & smoother morph
  const POINTS = 320;          // smoother than 200
  const BASE_R = 140;

  // Transition speed controls (requested: smooth + slow)
  const MORPH_MS_SHAPE = 2200; // shape-to-shape and blob->shape
  const MORPH_MS_BLOB  = 2400; // shape->blob and blob reset
  const ROTATE_MS = 1800;

  const group  = document.getElementById("shapeGroup");
  const helper = document.getElementById("helperPath");
  const cmd    = document.getElementById("cmd");

  const infoBtn  = document.getElementById("infoBtn");
  const modal    = document.getElementById("modal");
  const closeBtn = document.getElementById("closeBtn");
  const shapeListEl = document.getElementById("shapeList");

  // Render list
  SHAPES.forEach(s => {
    const li = document.createElement("li");
    li.textContent = s;
    shapeListEl.appendChild(li);
  });

  let fillColor = "#ffffff";
  let rotationDeg = 0;

  let mode = "blob";          // blob | shape
  let multiShape = false;     // multi-path => poly rendering to prevent bridging
  let raf = null, time = 0;

  // ----- Morph tween state (smooth & slow, fixes fast star->pause) -----
  let morphing = false;
  let morphStart = 0;
  let morphDur = MORPH_MS_SHAPE;
  let fromSets = null;
  let toSets = null;
  let currentSets = [makeBlobPoints()];

  function easeInOutCubic(t){
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;
  }

  // phase offsets for blob wobble (stable per vertex)
  const blobPhase = Array.from({length: POINTS}, (_, i) => {
    const th = (i / POINTS) * TAU;
    return 2.6*Math.sin(th*2.0 + 0.9) + 1.8*Math.sin(th*1.1 - 0.4);
  });

  // ====== Smoothing helpers ======
  function smoothArray(arr, passes=4){
    const n = arr.length;
    let a = arr.slice();
    for(let p=0;p<passes;p++){
      const b = new Array(n);
      for(let i=0;i<n;i++){
        const prev = a[(i-1+n)%n];
        const cur  = a[i];
        const next = a[(i+1)%n];
        b[i] = (prev + 2*cur + next) / 4;
      }
      a = b;
    }
    return a;
  }

  function smoothPoints(pts, passes=1){
    const n = pts.length;
    let a = pts.map(p => ({x:p.x,y:p.y}));
    for(let p=0;p<passes;p++){
      const b = new Array(n);
      for(let i=0;i<n;i++){
        const prev = a[(i-1+n)%n];
        const cur  = a[i];
        const next = a[(i+1)%n];
        b[i] = {
          x:(prev.x + 2*cur.x + next.x)/4,
          y:(prev.y + 2*cur.y + next.y)/4
        };
      }
      a = b;
    }
    return a;
  }

  // ====== Blob generation (rounder + evenly smooth everywhere) ======
  function makeBlobPoints(){
    const radii = [];
    for(let i=0;i<POINTS;i++){
      const th=(i/POINTS)*TAU;

      // rounder + fewer harsh frequencies
      const base =
        1
        + 0.05*Math.sin(th*2 + 0.6)
        + 0.03*Math.sin(th*3 - 1.1)
        + 0.015*Math.sin(th*5 + 2.0);

      radii.push(BASE_R * base);
    }

    // stronger smoothing to remove any “one-side kink”
    const smoothR = smoothArray(radii, 6);

    const pts=[];
    for(let i=0;i<POINTS;i++){
      const th=(i/POINTS)*TAU;
      const r = smoothR[i];
      pts.push({x:r*Math.cos(th), y:r*Math.sin(th)});
    }
    return pts;
  }

  // ====== Path builders (higher precision => smoother) ======
  const fmt = (n)=>Number(n).toFixed(3);

  function toSmoothPath(pts){
    const n = pts.length;
    const p = (i)=>pts[(i+n)%n];
    let d="";
    for(let i=0;i<n;i++){
      const p0=p(i-1), p1=p(i), p2=p(i+1), p3=p(i+2);
      const c1x = p1.x + (p2.x - p0.x)/6;
      const c1y = p1.y + (p2.y - p0.y)/6;
      const c2x = p2.x - (p3.x - p1.x)/6;
      const c2y = p2.y - (p3.y - p1.y)/6;
      if(i===0) d += `M ${fmt(p1.x)} ${fmt(p1.y)} `;
      d += `C ${fmt(c1x)} ${fmt(c1y)}, ${fmt(c2x)} ${fmt(c2y)}, ${fmt(p2.x)} ${fmt(p2.y)} `;
    }
    return d + "Z";
  }

  // For multi-part shapes: no bulging, no connecting
  function toPolyPath(pts){
    let d = `M ${fmt(pts[0].x)} ${fmt(pts[0].y)} `;
    for(let i=1;i<pts.length;i++){
      d += `L ${fmt(pts[i].x)} ${fmt(pts[i].y)} `;
    }
    return d + "Z";
  }

  // ====== Stabilize size/center ======
  function stabilizeSizeAndCenter(sets){
    let cx=0, cy=0, count=0;
    for(const pts of sets){
      for(const p of pts){ cx+=p.x; cy+=p.y; count++; }
    }
    cx/=count; cy/=count;

    for(const pts of sets){
      for(const p of pts){ p.x-=cx; p.y-=cy; }
    }

    let maxR=0;
    for(const pts of sets){
      for(const p of pts){ maxR=Math.max(maxR, Math.hypot(p.x,p.y)); }
    }
    const s = maxR > 0 ? (BASE_R / maxR) : 1;
    for(const pts of sets){
      for(const p of pts){ p.x*=s; p.y*=s; }
    }
  }

  function centroid(pts){
    let cx=0, cy=0;
    for(const p of pts){ cx+=p.x; cy+=p.y; }
    return {x:cx/pts.length, y:cy/pts.length};
  }

  // ====== Alignment fix (reduce twisting) ======
  function alignTargetToCurrent(currentPts, targetPts){
    const n = currentPts.length;
    const step = 6;
    function scoreFor(shift, reversed){
      let sum = 0;
      for(let i=0;i<n;i+=step){
        const ti = reversed ? (((shift - i) % n + n) % n) : ((i + shift) % n);
        const dx = currentPts[i].x - targetPts[ti].x;
        const dy = currentPts[i].y - targetPts[ti].y;
        sum += dx*dx + dy*dy;
      }
      return sum;
    }

    const coarseStep = 12;
    let bestShift = 0, bestRev = false, bestScore = Infinity;

    for(let sh=0; sh<n; sh+=coarseStep){
      for(const rev of [false,true]){
        const sc = scoreFor(sh, rev);
        if(sc < bestScore){
          bestScore = sc;
          bestShift = sh;
          bestRev = rev;
        }
      }
    }

    for(let d=-coarseStep; d<=coarseStep; d++){
      const sh = (bestShift + d + n) % n;
      for(const rev of [false,true]){
        const sc = scoreFor(sh, rev);
        if(sc < bestScore){
          bestScore = sc;
          bestShift = sh;
          bestRev = rev;
        }
      }
    }

    const out = new Array(n);
    for(let i=0;i<n;i++){
      const ti = bestRev ? (((bestShift - i) % n + n) % n) : ((i + bestShift) % n);
      out[i] = {x: targetPts[ti].x, y: targetPts[ti].y};
    }
    return out;
  }

  // ====== Sampling SVG paths ======
  function pointsFromPathD(d){
    helper.setAttribute("d", d);
    const L = helper.getTotalLength();
    if(!isFinite(L) || L <= 0) return null;

    const pts=[];
    for(let i=0;i<POINTS;i++){
      const p = helper.getPointAtLength((i/POINTS) * L);
      pts.push({x:p.x, y:p.y});
    }
    return pts;
  }

  function normalizeLoadedSets(sets){
    stabilizeSizeAndCenter(sets);

    // tiny per-piece shrink to avoid touching in multi shapes
    if(sets.length > 1){
      const shrink = 0.992;
      for(const pts of sets){
        const c = centroid(pts);
        for(const p of pts){
          p.x = c.x + (p.x - c.x) * shrink;
          p.y = c.y + (p.y - c.y) * shrink;
        }
      }
      stabilizeSizeAndCenter(sets);
    }
    return sets;
  }

  // ====== DOM helpers ======
  function ensurePathEls(n){
    while(group.children.length < n){
      const p = document.createElementNS("http://www.w3.org/2000/svg","path");
      p.setAttribute("fill", fillColor);
      group.appendChild(p);
    }
    while(group.children.length > n){
      group.removeChild(group.lastChild);
    }
    for(const el of group.children) el.setAttribute("fill", fillColor);
  }

  function setFill(c){
    fillColor = c;
    for(const el of group.children) el.setAttribute("fill", c);
  }

  function setRotation(deg){
    rotationDeg = deg;
    group.style.transitionDuration = ROTATE_MS + "ms";
    group.setAttribute("transform", `rotate(${rotationDeg})`);
  }

  // ====== Animation loop ======
  function start(){
    if(raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(tick);
  }

  function tick(now){
    // blob needs to keep animating for wobble even when not morphing
    time = now / 1000;

    // ----- morph tween -----
    if(morphing){
      const t = Math.min(1, (now - morphStart) / morphDur);
      const e = easeInOutCubic(t);

      const interp = fromSets.map((a, si) => {
        const b = toSets[si];
        const out = new Array(POINTS);
        for(let i=0;i<POINTS;i++){
          out[i] = {
            x: lerp(a[i].x, b[i].x, e),
            y: lerp(a[i].y, b[i].y, e),
          };
        }
        return out;
      });

      stabilizeSizeAndCenter(interp);
      currentSets = interp;

      if(t >= 1){
        morphing = false;
        // lock exact targets when done
        currentSets = toSets.map(pts => pts.map(p => ({x:p.x,y:p.y})));

        // if we're in "shape" mode, we can stop animating (no wobble needed)
        // but if blob mode, keep running for wobble
        if(mode === "shape"){
          render(); // final render
          raf = null;
          return;
        }
      }
    }

    render();
    raf = requestAnimationFrame(tick);
  }

  function render(){
    ensurePathEls(currentSets.length);

    for(let s=0; s<currentSets.length; s++){
      let renderPts = currentSets[s];

      if(mode === "blob"){
        const breathe = 1 + 0.018*Math.sin(time*0.9);

        const wob = renderPts.map((p,i)=>{
          const r = Math.hypot(p.x,p.y);
          const th = Math.atan2(p.y,p.x);

          const wobble =
            1
            + 0.040*Math.sin(time*1.5 + blobPhase[i] + s*0.5)
            + 0.018*Math.sin(time*2.1 + blobPhase[i]*0.7 + s*0.3);

          const rr = r * wobble * breathe;
          return { x: rr*Math.cos(th), y: rr*Math.sin(th) };
        });

        // extra smoothing pass => removes any “right-side” kink during wobble
        renderPts = smoothPoints(wob, 1);
      }

      const d = (multiShape ? toPolyPath(renderPts) : toSmoothPath(renderPts));
      group.children[s].setAttribute("d", d);
    }
  }

  // ====== Hybrid shape loader ======
  const cache = {};
  async function loadShapeByName(name){
    const file = name.toLowerCase().trim().replace(/\s+/g,"-") + ".svg";
    if(cache[file]) return cache[file];

    try{
      const res = await fetch("shapes/" + file, {cache:"force-cache"});
      if(!res.ok) return null;
      const txt = await res.text();
      const doc = new DOMParser().parseFromString(txt, "image/svg+xml");
      const paths = [...doc.querySelectorAll("path")];
      if(!paths.length) return null;

      const sets = [];
      for(const p of paths){
        const d = p.getAttribute("d");
        if(!d) continue;
        const pts = pointsFromPathD(d);
        if(pts) sets.push(pts);
      }
      if(!sets.length) return null;

      cache[file] = normalizeLoadedSets(sets);
      return cache[file];
    } catch {
      return null;
    }
  }

  // Spawn blobs to match multi-path count
  function spawnFromTargets(targetSetsIn){
    const spawned = targetSetsIn.map((tset)=>{
      const b = makeBlobPoints();
      const ct = centroid(tset);
      const cb = centroid(b);
      for(const p of b){
        p.x = (p.x - cb.x) + ct.x;
        p.y = (p.y - cb.y) + ct.y;
      }
      return b;
    });
    stabilizeSizeAndCenter(spawned);
    return spawned;
  }

  function deepCopySets(sets){
    return sets.map(pts => pts.map(p => ({x:p.x,y:p.y})));
  }

  function beginMorph(nextSets, durationMs){
    // normalize counts
    if(currentSets.length !== nextSets.length){
      currentSets = spawnFromTargets(nextSets);
    }

    // align each target path to its current path (reduces twist)
    const aligned = nextSets.map((pts, idx) => {
      const cur = currentSets[idx];
      const t = pts.map(p => ({x:p.x, y:p.y}));
      return alignTargetToCurrent(cur, t);
    });

    stabilizeSizeAndCenter(currentSets);
    stabilizeSizeAndCenter(aligned);

    fromSets = deepCopySets(currentSets);
    toSets = deepCopySets(aligned);
    morphStart = performance.now();
    morphDur = durationMs;
    morphing = true;

    start();
  }

  // ====== Commands ======
  function isCssColor(str){
    const s = str.trim();
    if(!s) return false;
    const test = document.createElement("div");
    test.style.color = "";
    test.style.color = s;
    return !!test.style.color;
  }

  function exportSVGString(){
    const vb = "-220 -220 440 440";
    const ds = [...group.children].map(p => p.getAttribute("d") || "").filter(Boolean);
    const paths = ds.map(d => `    <path d="${d}" fill="${fillColor}"/>`).join("\n");
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}">
  <g transform="rotate(${rotationDeg})">
${paths}
  </g>
</svg>\n`;
  }

  function doCopy(){
    navigator.clipboard.writeText(exportSVGString());
  }

  function doExport(){
    const text = exportSVGString();
    const blob = new Blob([text], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "shape.svg";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  async function applyShape(name){
    const v = name.trim();
    if(!v){
      // return to blob mode
      mode = "blob";
      multiShape = false;
      beginMorph([makeBlobPoints()], MORPH_MS_BLOB);
      return;
    }

    const sets = await loadShapeByName(v);
    if(!sets) return;

    mode = "shape";
    multiShape = (sets.length > 1);

    beginMorph(sets, MORPH_MS_SHAPE);
  }

  function chooseRandomShape(){
    const pick = SHAPES[Math.floor(Math.random() * SHAPES.length)];
    return pick;
  }

  cmd.addEventListener("keydown", async (e) => {
    if(e.key !== "Enter") return;

    const raw = cmd.value.trim();
    if(!raw){
      await applyShape("");
      return;
    }

    const lower = raw.toLowerCase();

    if(lower === "copy"){
      doCopy();
      cmd.value = "";
      return;
    }

    if(lower === "export"){
      doExport();
      cmd.value = "";
      return;
    }

    if(lower === "random"){
      const pick = chooseRandomShape();
      cmd.value = ""; // keep clean
      await applyShape(pick);
      return;
    }

    if(lower.startsWith("rotate ")){
      const n = parseFloat(raw.slice(7).trim());
      if(Number.isFinite(n)){
        setRotation(rotationDeg + n);
        cmd.value = "";
      }
      return;
    }

    if(isCssColor(raw)){
      setFill(raw);
      cmd.value = "";
      return;
    }

    await applyShape(raw);
  });

  // live: clearing input returns to blob (no enter needed)
  cmd.addEventListener("input", async () => {
    if(cmd.value.trim() === ""){
      await applyShape("");
    }
  });

  // ====== Info modal ======
  infoBtn.addEventListener("click", () => modal.classList.add("open"));
  closeBtn.addEventListener("click", () => modal.classList.remove("open"));
  modal.addEventListener("click", (e) => { if(e.target === modal) modal.classList.remove("open"); });
  window.addEventListener("keydown", (e) => { if(e.key === "Escape") modal.classList.remove("open"); });

  // ====== Boot ======
  setFill("#ffffff");
  setRotation(0);

  // start blob wobble immediately
  currentSets = [makeBlobPoints()];
  stabilizeSizeAndCenter(currentSets);
  start();
})();
</script>

</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Alive Blob → Any Shape (SVG) + Color + Export</title>
  <style>
    :root { --bg:#0b0f19; --fg:#e9eefc; --muted:#9aa6c3; }
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body {
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(1200px 700px at 50% 40%, #151d33 0%, var(--bg) 60%, #070a12 100%);
      color: var(--fg);
    }
    .wrap { width:min(820px, 94vw); text-align:center; }
    .stage {
      width:min(440px, 82vw); aspect-ratio:1/1; margin:0 auto 14px;
      display:grid; place-items:center;
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.55));
    }
    svg { width:100%; height:100%; overflow:visible; }
    .controls { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px; }
    input[type="text"]{
      width:min(620px, 94vw);
      padding:14px 16px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--fg);
      outline:none;
      font-size:16px;
    }
    input[type="text"]:focus{ border-color: rgba(135,177,255,.45); box-shadow:0 0 0 4px rgba(135,177,255,.12); }
    .row { margin-top:10px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap; align-items:center; }
    button{
      padding:10px 14px; border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--fg);
      cursor:pointer; font-size:14px;
    }
    button:hover { background: rgba(255,255,255,.10); }
    .colorWrap{
      display:flex; align-items:center; gap:10px;
      padding:8px 10px; border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
    }
    input[type="color"]{ width:44px; height:34px; border:none; background:transparent; padding:0; cursor:pointer; }
    .small { color:var(--muted); font-size:13px; line-height:1.4; margin-top:10px; }
    code { background: rgba(255,255,255,.06); padding:2px 6px; border-radius:8px; }
    .examples { margin-top:8px; color:var(--muted); font-size:13px; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="stage">
      <svg id="svgRoot" viewBox="-220 -220 440 440" xmlns="http://www.w3.org/2000/svg" aria-label="shape">
        <path id="shapePath" fill="#ffffff"></path>

        <!-- hidden helper path for sampling custom SVG path input -->
        <path id="helperPath" fill="none" stroke="none" d="" style="visibility:hidden;"></path>
      </svg>
    </div>

    <input id="cmd" type="text" autocomplete="off" spellcheck="false"
      placeholder="Type a shape command, or paste an SVG path starting with M... then press Enter" />

    <div class="row">
      <div class="colorWrap">
        <label for="colorText" style="font-size:13px;color:var(--muted)">Color</label>
        <input id="colorPicker" type="color" value="#ffffff" />
        <input id="colorText" type="text" value="#ffffff" style="width:160px; padding:10px 12px; font-size:14px;" />
      </div>

      <button id="exportBtn" type="button">Export SVG</button>
      <button id="copyBtn" type="button">Copy SVG</button>
      <button id="blobBtn" type="button">Blob mode</button>
    </div>

    <div class="examples">
      Examples: <code>circle</code> <code>triangle</code> <code>square</code> <code>ngon 9</code> <code>star 7</code> <code>color hotpink</code><br/>
      Custom: paste an SVG path like <code>M 0 -140 C ... Z</code> (any shape) or use <code>path: M ... Z</code>
    </div>

    <div class="small">
      Rules you asked for: the blob is only “alive” in <code>blob</code> mode. When you choose a shape (built-in or custom path),
      it morphs slowly and then <b>freezes perfectly</b>. Export saves exactly what you see.
    </div>
  </div>

<script>
(() => {
  // ========= Basics =========
  const TAU = Math.PI * 2;
  const lerp = (a,b,t) => a + (b-a)*t;

  const svgRoot = document.getElementById("svgRoot");
  const pathEl  = document.getElementById("shapePath");
  const helper  = document.getElementById("helperPath");

  const cmdInput = document.getElementById("cmd");
  const colorPicker = document.getElementById("colorPicker");
  const colorText   = document.getElementById("colorText");

  const exportBtn = document.getElementById("exportBtn");
  const copyBtn   = document.getElementById("copyBtn");
  const blobBtn   = document.getElementById("blobBtn");

  const POINTS = 120;     // smooth enough, still exports fine
  const BASE_R = 140;     // size in viewBox

  // Blob wobble only in blob mode
  const wobbleAmp = 0.085;
  const wobbleSpeed = 0.95;

  // modes:
  // - blob: animate forever
  // - shape: morph to target and freeze (stop animating) when settled
  let mode = "blob";
  let activeLabel = "blob";

  // points arrays: same length always
  let currentPts = makeBlobBasePoints(POINTS);
  let targetPts  = makeBlobBasePoints(POINTS);

  // per-point deterministic phases for organic motion
  const phase = Array.from({length: POINTS}, (_, i) => {
    const th = (i / POINTS) * TAU;
    return 3.1 * Math.sin(th * 2.7 + 1.2) + 2.0 * Math.sin(th * 1.3 - 0.5);
  });

  // last frozen path for export / stillness
  let frozenD = "";

  // ========= Path building (smooth closed curve) =========
  function pointsToClosedPath(pts) {
    const n = pts.length;
    const p = (i) => pts[(i + n) % n];
    let d = "";
    for (let i = 0; i < n; i++) {
      const p0 = p(i - 1), p1 = p(i), p2 = p(i + 1), p3 = p(i + 2);
      const c1x = p1.x + (p2.x - p0.x) / 6;
      const c1y = p1.y + (p2.y - p0.y) / 6;
      const c2x = p2.x - (p3.x - p1.x) / 6;
      const c2y = p2.y - (p3.y - p1.y) / 6;

      if (i === 0) d += `M ${p1.x.toFixed(2)} ${p1.y.toFixed(2)} `;
      d += `C ${c1x.toFixed(2)} ${c1y.toFixed(2)}, ${c2x.toFixed(2)} ${c2y.toFixed(2)}, ${p2.x.toFixed(2)} ${p2.y.toFixed(2)} `;
    }
    return d + "Z";
  }

  // ========= Built-in generators (return POINTS points) =========
  function makeCirclePoints(count, r=BASE_R) {
    const pts = [];
    for (let i=0; i<count; i++) {
      const th = (i / count) * TAU;
      pts.push({ x: r * Math.cos(th), y: r * Math.sin(th) });
    }
    return pts;
  }

  // Regular n-gon vertices, then resample perimeter to 'count'
  function makeNgonPoints(count, n, r=BASE_R, rotation=-Math.PI/2) {
    const verts = [];
    for (let k=0; k<n; k++) {
      const th = rotation + (k / n) * TAU;
      verts.push({ x: r * Math.cos(th), y: r * Math.sin(th) });
    }
    return resampleClosedPolyline(verts, count);
  }

  function makeStarPoints(count, spikes=5, inner=0.55, outer=1.0, r=BASE_R, rotation=-Math.PI/2) {
    const verts = [];
    const total = spikes * 2;
    for (let k=0; k<total; k++) {
      const isOuter = (k % 2 === 0);
      const rr = r * (isOuter ? outer : inner);
      const th = rotation + (k / total) * TAU;
      verts.push({ x: rr * Math.cos(th), y: rr * Math.sin(th) });
    }
    return resampleClosedPolyline(verts, count);
  }

  function makeBlobBasePoints(count, r=BASE_R) {
    const pts = [];
    for (let i=0; i<count; i++) {
      const th = (i / count) * TAU;
      const mult =
        1 +
        0.16 * Math.sin(th * 2 + 0.8) +
        0.10 * Math.sin(th * 3 - 1.4) +
        0.07 * Math.sin(th * 5 + 2.2);
      pts.push({ x: (r * mult) * Math.cos(th), y: (r * mult) * Math.sin(th) });
    }
    // normalize size
    return normalizePointsToRadius(pts, r);
  }

  // ========= Resampling + normalization =========
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  function resampleClosedPolyline(verts, count) {
    // verts are corner points of a closed polyline (implicit close)
    const pts = verts.slice();
    // compute edge lengths
    const segs = [];
    let total = 0;
    for (let i=0; i<pts.length; i++) {
      const a = pts[i], b = pts[(i+1) % pts.length];
      const L = dist(a,b);
      segs.push(L);
      total += L;
    }
    const step = total / count;

    const out = [];
    let segIndex = 0;
    let segPos = 0; // distance along current segment
    let traveled = 0;

    // starting point
    let a = pts[0];
    let b = pts[1 % pts.length];
    let segLen = segs[0];

    for (let i=0; i<count; i++) {
      const targetDist = i * step;
      while (traveled + (segLen - segPos) < targetDist) {
        traveled += (segLen - segPos);
        segIndex = (segIndex + 1) % pts.length;
        a = pts[segIndex];
        b = pts[(segIndex + 1) % pts.length];
        segLen = segs[segIndex];
        segPos = 0;
      }
      const remain = targetDist - traveled;
      const t = segLen === 0 ? 0 : (segPos + remain) / segLen;
      out.push({ x: lerp(a.x, b.x, t), y: lerp(a.y, b.y, t) });
    }
    return out;
  }

  function normalizePointsToRadius(pts, targetR=BASE_R) {
    // center at centroid then scale so max radius ~= targetR
    const c = pts.reduce((s,p)=>({x:s.x+p.x,y:s.y+p.y}), {x:0,y:0});
    c.x /= pts.length; c.y /= pts.length;
    const centered = pts.map(p => ({x:p.x-c.x, y:p.y-c.y}));
    let maxR = 0;
    for (const p of centered) maxR = Math.max(maxR, Math.hypot(p.x,p.y));
    const scale = maxR === 0 ? 1 : (targetR / maxR);
    return centered.map(p => ({x:p.x*scale, y:p.y*scale}));
  }

  // ========= Custom shape from SVG path =========
  function pointsFromPathD(d, count) {
    try {
      helper.setAttribute("d", d);
      const len = helper.getTotalLength();
      if (!isFinite(len) || len <= 0) return null;

      const pts = [];
      for (let i=0; i<count; i++) {
        const p = helper.getPointAtLength((i / count) * len);
        pts.push({ x: p.x, y: p.y });
      }
      return normalizePointsToRadius(pts, BASE_R);
    } catch {
      return null;
    }
  }

  // ========= Command parsing =========
  function looksLikePath(str) {
    const s = str.trim();
    return /^[Mm]\s*[-\d.]/.test(s); // starts with M or m + number
  }

  function applyColor(colorStr) {
    const s = colorStr.trim();
    if (!s) return;
    // Let the browser validate CSS color by assigning it
    const test = document.createElement("div");
    test.style.color = "";
    test.style.color = s;
    if (test.style.color) {
      pathEl.setAttribute("fill", s);
      colorText.value = s;
      // update picker if it's a hex
      if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(s)) colorPicker.value = s.length===4 ? expandHex3(s) : s;
    }
  }

  function expandHex3(h) {
    // "#abc" -> "#aabbcc"
    return "#" + h.slice(1).split("").map(ch => ch+ch).join("");
  }

  function setTargetPoints(label, pts) {
    activeLabel = label;
    targetPts = pts;

    frozenD = "";
    if (label === "blob") {
      mode = "blob";
    } else {
      mode = "shape";
    }
    restartLoop();
  }

  function handleCommand(raw) {
    const input = raw.trim();
    if (!input) return;

    // Allow multiple instructions separated by ";"
    const parts = input.split(";").map(p => p.trim()).filter(Boolean);

    for (const part of parts) {
      const lower = part.toLowerCase();

      // Color commands: "color red" or just "#ff00aa"
      if (lower.startsWith("color ")) {
        applyColor(part.slice(6));
        continue;
      }
      if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(part) || /^rgb\(|^hsl\(|^[a-z]+$/i.test(part)) {
        // If it's a valid CSS color, applyColor will accept it
        const before = pathEl.getAttribute("fill");
        applyColor(part);
        if (pathEl.getAttribute("fill") !== before) continue;
      }

      // Explicit path: "path: M ... Z"
      if (lower.startsWith("path:")) {
        const d = part.slice(5).trim();
        const pts = pointsFromPathD(d, POINTS);
        if (pts) setTargetPoints("custom", pts);
        continue;
      }

      // If user pasted a raw path starting with M
      if (looksLikePath(part)) {
        const pts = pointsFromPathD(part, POINTS);
        if (pts) setTargetPoints("custom", pts);
        continue;
      }

      // Built-in-ish but not limited: allow "ngon N" and "star N"
      if (lower === "blob") {
        setTargetPoints("blob", makeBlobBasePoints(POINTS));
        continue;
      }
      if (lower === "circle") {
        setTargetPoints("circle", makeCirclePoints(POINTS, BASE_R));
        continue;
      }
      if (lower === "triangle") {
        setTargetPoints("triangle", makeNgonPoints(POINTS, 3));
        continue;
      }
      if (lower === "square") {
        setTargetPoints("square", makeNgonPoints(POINTS, 4));
        continue;
      }
      if (lower === "pentagon") {
        setTargetPoints("pentagon", makeNgonPoints(POINTS, 5));
        continue;
      }
      if (lower === "hexagon") {
        setTargetPoints("hexagon", makeNgonPoints(POINTS, 6));
        continue;
      }
      if (lower.startsWith("ngon ")) {
        const n = parseInt(lower.split(/\s+/)[1], 10);
        if (Number.isFinite(n) && n >= 3 && n <= 200) {
          setTargetPoints(`ngon${n}`, makeNgonPoints(POINTS, n));
        }
        continue;
      }
      if (lower.startsWith("star ")) {
        const n = parseInt(lower.split(/\s+/)[1], 10);
        if (Number.isFinite(n) && n >= 3 && n <= 50) {
          setTargetPoints(`star${n}`, makeStarPoints(POINTS, n, 0.52, 1.0));
        }
        continue;
      }

      // If they typed "anything", we can’t guess geometry from arbitrary words.
      // BUT we *can* guide them: paste an SVG path (unlimited).
      // So if unrecognized: no crash—just switch back to blob.
      setTargetPoints("blob", makeBlobBasePoints(POINTS));
    }
  }

  // ========= Animation =========
  let last = performance.now();
  let time = 0;
  let rafId = null;

  const morphSpeed = 2.6; // slower morph as requested

  function restartLoop() {
    if (rafId) cancelAnimationFrame(rafId);
    last = performance.now();
    rafId = requestAnimationFrame(tick);
  }

  function tick(now) {
    const dt = (now - last) / 1000;
    last = now;
    time += dt;

    // Morph current -> target
    const alpha = 1 - Math.exp(-morphSpeed * dt);
    let maxDelta = 0;

    for (let i=0; i<POINTS; i++) {
      const a = currentPts[i], b = targetPts[i];
      const nx = lerp(a.x, b.x, alpha);
      const ny = lerp(a.y, b.y, alpha);
      maxDelta = Math.max(maxDelta, Math.hypot(nx - a.x, ny - a.y));
      a.x = nx; a.y = ny;
    }

    // Render: wobble only in blob mode
    let renderPts;
    if (mode === "blob") {
      renderPts = currentPts.map((p,i) => {
        const th = Math.atan2(p.y, p.x);
        const r  = Math.hypot(p.x, p.y);

        const w =
          1 +
          wobbleAmp * Math.sin(time * (wobbleSpeed * 2.0) + phase[i]) +
          (wobbleAmp * 0.55) * Math.sin(time * (wobbleSpeed * 3.1) + phase[i] * 0.7);

        return { x: (r*w) * Math.cos(th), y: (r*w) * Math.sin(th) };
      });
    } else {
      // shape mode: EXACT still, no wobble
      renderPts = currentPts;
    }

    const d = pointsToClosedPath(renderPts);
    pathEl.setAttribute("d", d);

    // Freeze when settled in shape mode
    if (mode === "shape" && maxDelta < 0.02) {
      frozenD = pointsToClosedPath(currentPts); // store stable, non-wobble
      pathEl.setAttribute("d", frozenD);
      rafId = null; // stop animating completely
      return;
    }

    rafId = requestAnimationFrame(tick);
  }

  // ========= Color controls =========
  function setColorBoth(val) {
    applyColor(val);
  }

  colorPicker.addEventListener("input", () => setColorBoth(colorPicker.value));
  colorText.addEventListener("keydown", (e) => {
    if (e.key === "Enter") setColorBoth(colorText.value);
  });

  // ========= Export =========
  function getExportD() {
    return frozenD || pathEl.getAttribute("d") || "";
  }

  function exportSVGString() {
    const vb = svgRoot.getAttribute("viewBox") || "-220 -220 440 440";
    const fill = pathEl.getAttribute("fill") || "#ffffff";
    const d = getExportD();
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}">\n  <path d="${d}" fill="${fill}"/>\n</svg>\n`;
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], {type: "image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  exportBtn.addEventListener("click", () => {
    const name = activeLabel && activeLabel !== "blob" ? activeLabel : "shape";
    downloadText(`${name}.svg`, exportSVGString());
  });

  copyBtn.addEventListener("click", async () => {
    const txt = exportSVGString();
    try {
      await navigator.clipboard.writeText(txt);
      copyBtn.textContent = "Copied!";
      setTimeout(() => (copyBtn.textContent = "Copy SVG"), 900);
    } catch {
      window.prompt("Copy SVG:", txt);
    }
  });

  blobBtn.addEventListener("click", () => {
    cmdInput.value = "blob";
    setTargetPoints("blob", makeBlobBasePoints(POINTS));
    restartLoop();
  });

  // ========= Input events =========
  cmdInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") handleCommand(cmdInput.value);
  });

  // ========= Boot =========
  // default white fill
  pathEl.setAttribute("fill", "#ffffff");
  setTargetPoints("blob", makeBlobBasePoints(POINTS));
  restartLoop();
})();
</script>
</body>
</html>

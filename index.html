<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blob → Shape (Hybrid SVG)</title>

<style>
:root{
  --bg:#0b0f19;
  --fg:#e9eefc;
  --ui:rgba(255,255,255,.08);
  --ui-b:rgba(255,255,255,.14);
}
html,body{height:100%;margin:0}
body{
  background:radial-gradient(1200px 700px at 50% 40%,#151d33 0%,var(--bg) 60%,#070a12 100%);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--fg);
  overflow:hidden;
}

/* center */
.stage{
  position:fixed;
  inset:0;
  display:grid;
  place-items:center;
  pointer-events:none;
}
svg{
  width:min(520px,86vw);
  height:auto;
  filter:drop-shadow(0 18px 40px rgba(0,0,0,.55));
}

/* input */
.bottom{
  position:fixed;
  left:50%;
  bottom:22px;
  transform:translateX(-50%);
  width:min(720px,92vw);
}
.bottom input{
  width:100%;
  padding:14px 16px;
  border-radius:14px;
  border:1px solid var(--ui-b);
  background:var(--ui);
  color:var(--fg);
  outline:none;
  font-size:16px;
}

/* toolbar */
.toolbar{
  position:fixed;
  top:14px;
  right:14px;
  display:flex;
  gap:10px;
  align-items:center;
}
.btn{
  border:1px solid var(--ui-b);
  background:var(--ui);
  color:var(--fg);
  border-radius:12px;
  padding:10px 12px;
  font-size:14px;
  cursor:pointer;
}
.btn:hover{background:rgba(255,255,255,.12)}

/* color */
.color{
  position:relative;
}
.color-dot{
  width:32px;height:32px;
  border-radius:50%;
  border:1px solid var(--ui-b);
  cursor:pointer;
}
.color-panel{
  position:absolute;
  top:40px;
  right:0;
  background:rgba(10,14,25,.95);
  border:1px solid var(--ui-b);
  border-radius:12px;
  padding:10px;
  display:none;
  gap:8px;
}
.color-panel.open{display:flex}
.color-panel input[type="color"]{width:42px;height:32px;border:none;background:none}
.color-panel input[type="text"]{
  width:120px;
  background:var(--ui);
  border:1px solid var(--ui-b);
  color:var(--fg);
  border-radius:8px;
  padding:6px 8px;
}

/* rotate */
.rotate{
  display:flex;
  align-items:center;
  gap:6px;
}
.rotate input{width:80px}
</style>
</head>

<body>

<!-- toolbar -->
<div class="toolbar">
  <div class="color">
    <div id="colorDot" class="color-dot"></div>
    <div id="colorPanel" class="color-panel">
      <input id="colorPicker" type="color" value="#ffffff"/>
      <input id="colorText" type="text" value="#ffffff"/>
    </div>
  </div>

  <div class="rotate">
    <span>↻</span>
    <input id="rotateRange" type="range" min="0" max="360" value="0"/>
  </div>

  <button id="exportBtn" class="btn">Export</button>
  <button id="copyBtn" class="btn">Copy</button>
  <button id="infoBtn" class="btn">Info</button>
</div>

<!-- svg -->
<div class="stage">
<svg id="svgRoot" viewBox="-220 -220 440 440" xmlns="http://www.w3.org/2000/svg">
  <g id="shapeGroup">
    <path id="shapePath" fill="#ffffff"></path>
  </g>
  <path id="helperPath" fill="none" stroke="none" visibility="hidden"/>
</svg>
</div>

<!-- input -->
<div class="bottom">
  <input id="cmd" placeholder="type a shape name (e.g. lightning bolt) or clear for blob"/>
</div>

<script>
(() => {
const TAU=Math.PI*2, lerp=(a,b,t)=>a+(b-a)*t;
const POINTS=120, BASE_R=140;

const pathEl=document.getElementById("shapePath");
const helper=document.getElementById("helperPath");
const cmd=document.getElementById("cmd");
const group=document.getElementById("shapeGroup");

const colorDot=document.getElementById("colorDot");
const colorPanel=document.getElementById("colorPanel");
const colorPicker=document.getElementById("colorPicker");
const colorText=document.getElementById("colorText");

const rotateRange=document.getElementById("rotateRange");

let mode="blob", currentPts=blobPts(), targetPts=blobPts();
let frozenD="", raf=null, time=0, last=performance.now();

/* ---------- geometry ---------- */
function blobPts(){
  const pts=[];
  for(let i=0;i<POINTS;i++){
    const t=i/POINTS*TAU;
    const m=1+.16*Math.sin(t*2)+.1*Math.sin(t*3)+.07*Math.sin(t*5);
    pts.push({x:BASE_R*m*Math.cos(t),y:BASE_R*m*Math.sin(t)});
  }
  return normalize(pts);
}
function normalize(pts){
  let cx=0,cy=0;
  pts.forEach(p=>{cx+=p.x;cy+=p.y});
  cx/=pts.length;cy/=pts.length;
  pts=pts.map(p=>({x:p.x-cx,y:p.y-cy}));
  let max=0;pts.forEach(p=>max=Math.max(max,Math.hypot(p.x,p.y)));
  const s=BASE_R/max;
  return pts.map(p=>({x:p.x*s,y:p.y*s}));
}
function toPath(pts){
  const p=i=>pts[(i+pts.length)%pts.length];
  let d="";
  for(let i=0;i<pts.length;i++){
    const p0=p(i-1),p1=p(i),p2=p(i+1),p3=p(i+2);
    const c1x=p1.x+(p2.x-p0.x)/6;
    const c1y=p1.y+(p2.y-p0.y)/6;
    const c2x=p2.x-(p3.x-p1.x)/6;
    const c2y=p2.y-(p3.y-p1.y)/6;
    if(!i)d+=`M ${p1.x} ${p1.y} `;
    d+=`C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y} `;
  }
  return d+"Z";
}
function ptsFromPath(d){
  helper.setAttribute("d",d);
  const L=helper.getTotalLength();
  const pts=[];
  for(let i=0;i<POINTS;i++){
    const p=helper.getPointAtLength(i/POINTS*L);
    pts.push({x:p.x,y:p.y});
  }
  return normalize(pts);
}

/* ---------- shape loading ---------- */
let cache={};
async function loadShape(name){
  const file=name.toLowerCase().replace(/\s+/g,"-")+".svg";
  if(cache[file]) return cache[file];
  try{
    const res=await fetch("shapes/"+file);
    if(!res.ok) return null;
    const txt=await res.text();
    const doc=new DOMParser().parseFromString(txt,"image/svg+xml");
    const path=doc.querySelector("path");
    if(!path) return null;
    const pts=ptsFromPath(path.getAttribute("d"));
    cache[file]=pts;
    return pts;
  }catch{return null}
}

/* ---------- animation ---------- */
function start(){
  if(raf) cancelAnimationFrame(raf);
  last=performance.now();
  raf=requestAnimationFrame(tick);
}
function tick(now){
  const dt=(now-last)/1000;last=now;time+=dt;
  let done=true;
  for(let i=0;i<POINTS;i++){
    const a=currentPts[i],b=targetPts[i];
    a.x=lerp(a.x,b.x,1-Math.exp(-3*dt));
    a.y=lerp(a.y,b.y,1-Math.exp(-3*dt));
    if(Math.hypot(a.x-b.x,a.y-b.y)>0.05) done=false;
  }
  let render=currentPts;
  if(mode==="blob"){
    render=currentPts.map((p,i)=>{
      const r=Math.hypot(p.x,p.y);
      const th=Math.atan2(p.y,p.x);
      const w=1+.08*Math.sin(time*2+i);
      return{x:r*w*Math.cos(th),y:r*w*Math.sin(th)};
    });
  }
  const d=toPath(render);
  pathEl.setAttribute("d",d);
  if(mode==="shape" && done){
    frozenD=d;raf=null;return;
  }
  raf=requestAnimationFrame(tick);
}

/* ---------- input logic ---------- */
let lastName="";
cmd.addEventListener("input", async()=>{
  const v=cmd.value.trim();
  if(!v){
    mode="blob";targetPts=blobPts();start();return;
  }
  if(v===lastName) return;
  const pts=await loadShape(v);
  if(pts){
    lastName=v;
    mode="shape";
    targetPts=pts;
    frozenD="";
    start();
  }
});

/* ---------- color ---------- */
function setColor(c){
  pathEl.setAttribute("fill",c);
  colorDot.style.background=c;
}
setColor("#ffffff");

colorDot.onclick=()=>colorPanel.classList.toggle("open");
colorPicker.oninput=()=>{setColor(colorPicker.value);colorText.value=colorPicker.value};
colorText.onchange=()=>setColor(colorText.value);
document.addEventListener("click",e=>{
  if(!colorPanel.contains(e.target)&&e.target!==colorDot)colorPanel.classList.remove("open");
});

/* ---------- rotate ---------- */
rotateRange.oninput=()=>{
  group.setAttribute("transform",`rotate(${rotateRange.value})`);
};

/* ---------- export ---------- */
function svgString(){
  return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="-220 -220 440 440">
  <g transform="rotate(${rotateRange.value})">
    <path d="${frozenD||pathEl.getAttribute("d")}" fill="${pathEl.getAttribute("fill")}"/>
  </g>
</svg>`;
}
document.getElementById("exportBtn").onclick=()=>{
  const a=document.createElement("a");
  a.href=URL.createObjectURL(new Blob([svgString()],{type:"image/svg+xml"}));
  a.download="shape.svg";a.click();
};
document.getElementById("copyBtn").onclick=()=>navigator.clipboard.writeText(svgString());

/* ---------- boot ---------- */
start();
})();
</script>
</body>
</html>

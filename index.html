<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Blob → Shape</title>
  <style>
    :root{
      --bg:#0b0f19;
      --fg:#e9eefc;
      --muted:rgba(233,238,252,.68);
      --ui:rgba(255,255,255,.08);
      --ui-b:rgba(255,255,255,.14)
    }
    html,body{height:100%;margin:0}
    body{
      background:radial-gradient(1200px 700px at 50% 40%,#151d33 0%,var(--bg) 60%,#070a12 100%);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--fg);
      overflow:hidden
    }
    .stage{
      position:fixed;inset:0;display:grid;place-items:center;pointer-events:none
    }
    svg{
      width:100vw;height:100vh;display:block;
      filter:drop-shadow(0 18px 40px rgba(0,0,0,.55))
    }

    .bottom{
      position:fixed;left:50%;bottom:22px;transform:translateX(-50%);
      width:min(780px,92vw);
      pointer-events:auto;z-index:20
    }
    .bottom input{
      width:100%;
      padding:14px 16px;
      border-radius:14px;
      border:1px solid var(--ui-b);
      background:var(--ui);
      color:var(--fg);
      outline:none;
      font-size:16px;
      transition:border-color 200ms ease,box-shadow 200ms ease
    }
    .bottom input.ok{border-color:rgba(255,255,255,.55)}
    .bottom input.err{
      border-color:rgba(255,120,120,.75);
      box-shadow:0 0 0 3px rgba(255,120,120,.18)
    }
    .bottom input.busy{
      border-color:rgba(255,255,255,.85);
      animation:pulse 900ms ease-in-out infinite
    }
    @keyframes pulse{
      0%,100%{box-shadow:0 0 0 0 rgba(255,255,255,.0)}
      50%{box-shadow:0 0 0 6px rgba(255,255,255,.18)}
    }

    #shapeGroup{transform-origin:0 0}
    svg path{transition:fill 600ms ease}

    .infoBtn{
      position:fixed;top:14px;right:14px;
      width:38px;height:38px;
      border-radius:12px;
      border:1px solid rgba(0,0,0,.18);
      background:#d9d9d9;color:#000;
      display:grid;place-items:center;
      cursor:pointer;
      pointer-events:auto;
      font-weight:800;z-index:80
    }
    .infoBtn:hover{background:#e6e6e6}

    .modal{
      position:fixed;inset:0;background:rgba(0,0,0,.55);
      display:none;align-items:center;justify-content:center;
      pointer-events:auto;z-index:90
    }
    .modal.open{display:flex}
    .card{
      width:min(980px,92vw);
      background:rgba(10,14,25,.95);
      border:1px solid var(--ui-b);
      border-radius:16px;
      padding:16px;
      box-shadow:0 18px 60px rgba(0,0,0,.6)
    }
    .card h3{margin:0 0 10px;font-size:16px}
    .card p{margin:8px 0;color:var(--muted);font-size:14px;line-height:1.45}

    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
    .box{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      border-radius:12px;
      padding:10px;
      min-height:120px
    }
    .box h4{margin:0 0 8px;font-size:14px;color:var(--fg)}

    .list{
      margin:0;padding-left:18px;
      color:var(--muted);
      font-size:14px;
      line-height:1.55
    }
    .list li{margin:0 0 8px 0}

    #shapeList{
      max-height:220px;
      overflow-y:auto;
      padding-right:10px;
    }
    #shapeList::-webkit-scrollbar{width:10px}
    #shapeList::-webkit-scrollbar-thumb{
      background:rgba(255,255,255,.16);
      border-radius:10px
    }

    code{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      padding:2px 6px;border-radius:8px;
      color:var(--fg);
      font-size:13px
    }
    .actions{display:flex;justify-content:flex-end;margin-top:12px}
    .btn{
      border:1px solid var(--ui-b);
      background:var(--ui);
      color:var(--fg);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      cursor:pointer
    }
    .btn:hover{background:rgba(255,255,255,.12)}

    #editLayer{display:none}
    body.editing #editLayer{display:block}

    .handle{cursor:grab;pointer-events:auto}
    .handle:active{cursor:grabbing}
    .handleOutline{fill:rgba(0,0,0,.28)}
    .handleCore{fill:rgba(255,255,255,.95)}
    .handleRing{fill:none;stroke:rgba(255,255,255,.35);stroke-width:1.5}

    .fullscreen{
      position:fixed;inset:0;
      pointer-events:auto;
      z-index:10;
      background:transparent;
      display:none;
      touch-action:none
    }
    .fullscreen.on{display:block}
  </style>
</head>
<body>
  <button class="infoBtn" id="infoBtn" aria-label="Info">i</button>
  <div class="fullscreen" id="panLayer"></div>

  <div class="stage">
    <svg id="svgRoot" viewBox="-220 -220 440 440" xmlns="http://www.w3.org/2000/svg">
      <g id="world">
        <g id="shapeGroup"></g>
        <g id="editLayer"></g>
      </g>
      <g id="measureGroup" visibility="hidden"></g>
    </svg>
  </div>

  <div class="bottom">
    <input id="cmd" placeholder="Enter: shape | blob | random | randomize | stoprandom | previous | drag | zoom 10 | zoom -10"
      autocomplete="off" spellcheck="false"/>
  </div>

  <div class="modal" id="modal" role="dialog" aria-modal="true">
    <div class="card">
      <h3>Info</h3>
      <p>Enter runs. Empty + Enter goes to <code>blob</code>. <code>randomize</code> changes every 5s.</p>

      <div class="grid">
        <div class="box">
          <h4>Commands</h4>
          <ul class="list">
            <li><code>blob</code></li>
            <li><code>random</code></li>
            <li><code>randomize</code> — every 5s</li>
            <li><code>stoprandom</code></li>
            <li><code>previous</code></li>
            <li><code>drag</code></li>
            <li><code>zoom 10</code> / <code>zoom -10</code> / <code>zoom 150</code></li>
            <li><code>edit</code></li>
            <li><code>copy</code></li>
            <li><code>export</code></li>
          </ul>
        </div>

        <div class="box">
          <h4>Shapes list</h4>
          <ul class="list" id="shapeList"></ul>
        </div>
      </div>

      <div class="actions">
        <button class="btn" id="closeBtn">Close</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const TAU = Math.PI * 2;
  const lerp = (a,b,t) => a + (b-a)*t;
  const fmt = n => Number(n).toFixed(3);

  const SHAPES = [
    "circle","oval","triangle","square","rectangle","diamond","pentagon","hexagon","star","heart",
    "lightning bolt","plus","cross","check","close","menu","search","home","user","play","pause","stop",
    "download","upload","arrow up","arrow right","chevron","capsule","drop","trapezoid","parallelogram",
    "settings","notification","netherlands"
  ];

  const POINTS = 720;
  const BASE_R = 140;
  const TARGET_TOTAL_AREA = Math.PI * BASE_R * BASE_R * 1.22;

  const MS_DIRECT = 2600;
  const MS_MIX = 3200;
  const MS_ZOOM = 900;

  const BLOB_CTRL = 28;

  // "Illustrator-ish" edit feel: soft selection radius (in SVG units)
  const EDIT_SOFT_RADIUS = 28;   // bigger = smoother deformation
  const EDIT_SOFT_POWER  = 2.2;  // falloff curve

  const svgRoot = document.getElementById("svgRoot");
  const world = document.getElementById("world");
  const group = document.getElementById("shapeGroup");
  const editLayer = document.getElementById("editLayer");
  const measureGroup = document.getElementById("measureGroup");
  const cmd = document.getElementById("cmd");
  const infoBtn = document.getElementById("infoBtn");
  const modal = document.getElementById("modal");
  const closeBtn = document.getElementById("closeBtn");
  const shapeListEl = document.getElementById("shapeList");
  const panLayer = document.getElementById("panLayer");

  SHAPES.forEach(s => {
    const li = document.createElement("li");
    li.textContent = s;
    shapeListEl.appendChild(li);
  });

  let fillColor = "#ffffff";
  let rotationDeg = 0;

  let mode = "blob";
  let raf = null;

  let morphing=false, morphStart=0, morphDur=MS_DIRECT;
  let fromSets=null, toSets=null;
  let morphMeta=null; // {type:'split'|'combine'|'same', k, targetSingleSets}

  let currentSets=[makeCirclePoints(BASE_R)];
  let currentName="blob";

  let zoomPct=55;

  // move shape slightly up (so input field has room)
  let panX=0;
  let panY=-42;

  let zoomAnim=null;

  let dragEnabled=false, dragging=false;
  let panStart=null;
  let pointerStart=null;

  let autoTimer=null, autoRunning=false;
  let history=["blob"];

  let isEditing=false;

  function easeInOut(t){
    return t<.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
  }
  function easeOut(t){ return 1 - Math.pow(1-t,3); }

  function setBusy(on){ cmd.classList.toggle("busy", !!on); }
  function setOk(){ cmd.classList.remove("err"); cmd.classList.add("ok"); }
  function setErr(){
    cmd.classList.remove("ok");
    cmd.classList.add("err");
    setTimeout(() => cmd.classList.remove("err"), 900);
  }

  function updateWorld(){
    const s = zoomPct/100;
    world.setAttribute("transform", `translate(${fmt(panX)} ${fmt(panY)}) scale(${fmt(s)})`);
  }

  function animateZoomTo(target){
    target = Math.max(10, Math.min(400, target));
    zoomAnim = { start: performance.now(), from: zoomPct, to: target };
    start();
  }

  function setZoom(val){
    let n = Number(val);
    if(!Number.isFinite(n)) return;
    let target = Math.abs(n) < 50 ? zoomPct + n : n;
    animateZoomTo(target);
  }

  function makeCirclePoints(r){
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const th=i/POINTS*TAU;
      pts.push({x:r*Math.cos(th), y:r*Math.sin(th)});
    }
    return pts;
  }

  function makeEllipsePoints(rx, ry){
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const th=i/POINTS*TAU;
      pts.push({x:rx*Math.cos(th), y:ry*Math.sin(th)});
    }
    return pts;
  }

  function makeRegularPolygonPoints(sides, radius){
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const th=i/POINTS*TAU;
      const a = ((th % TAU) + TAU) % TAU;
      const step = TAU / sides;
      const k = Math.floor(a / step);
      const a0 = k*step, a1 = (k+1)*step;
      const m = (a - a0) / (a1 - a0);

      const v0 = {x: Math.cos(a0)*radius, y: Math.sin(a0)*radius};
      const v1 = {x: Math.cos(a1)*radius, y: Math.sin(a1)*radius};

      pts.push({x: lerp(v0.x,v1.x,m), y: lerp(v0.y,v1.y,m)});
    }
    return pts;
  }

  function makeDiamondPoints(radius){
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const th=i/POINTS*TAU;
      const x=Math.cos(th), y=Math.sin(th);
      const s = 1/(Math.abs(x)+Math.abs(y));
      pts.push({x:x*s*radius, y:y*s*radius});
    }
    return pts;
  }

  function centroid(pts){
    let cx=0, cy=0;
    for(const p of pts){ cx+=p.x; cy+=p.y; }
    return {x:cx/pts.length, y:cy/pts.length};
  }

  function polygonArea(pts){
    let a=0;
    for(let i=0;i<pts.length;i++){
      const p=pts[i], q=pts[(i+1)%pts.length];
      a += p.x*q.y - q.x*p.y;
    }
    return a * .5;
  }

  function totalAreaAbs(sets){
    let sum=0;
    for(const pts of sets) sum += Math.abs(polygonArea(pts));
    return sum;
  }

  function stabilizeCenter(sets){
    let cx=0, cy=0, count=0;
    for(const pts of sets) for(const p of pts){ cx+=p.x; cy+=p.y; count++; }
    cx/=count; cy/=count;
    for(const pts of sets) for(const p of pts){ p.x-=cx; p.y-=cy; }
  }

  function scaleSets(sets,s){
    for(const pts of sets) for(const p of pts){ p.x*=s; p.y*=s; }
  }

  function normalizeTotal(sets){
    stabilizeCenter(sets);
    const a = totalAreaAbs(sets);
    const s = a>1e-6 ? Math.sqrt(TARGET_TOTAL_AREA/a) : 1;
    scaleSets(sets,s);
    stabilizeCenter(sets);
  }

  function toSmoothPath(pts){
    const n=pts.length, p=i=>pts[(i+n)%n];
    let d="";
    for(let i=0;i<n;i++){
      const p0=p(i-1), p1=p(i), p2=p(i+1), p3=p(i+2);
      const c1x=p1.x+(p2.x-p0.x)/6, c1y=p1.y+(p2.y-p0.y)/6;
      const c2x=p2.x-(p3.x-p1.x)/6, c2y=p2.y-(p3.y-p1.y)/6;
      if(i===0) d += `M ${fmt(p1.x)} ${fmt(p1.y)} `;
      d += `C ${fmt(c1x)} ${fmt(c1y)}, ${fmt(c2x)} ${fmt(c2y)}, ${fmt(p2.x)} ${fmt(p2.y)} `;
    }
    return d+"Z";
  }

  function ensurePaths(n){
    while(group.children.length<n){
      const p=document.createElementNS("http://www.w3.org/2000/svg","path");
      p.setAttribute("fill", fillColor);
      p.setAttribute("opacity","1");
      group.appendChild(p);
    }
    while(group.children.length>n) group.removeChild(group.lastChild);
    for(const el of group.children){
      el.setAttribute("fill", fillColor);
      el.setAttribute("opacity","1");
    }
  }

  function setFill(c){
    fillColor=c;
    for(const el of group.children) el.setAttribute("fill", c);
  }

  function setRotation(deg){
    rotationDeg=deg;
    group.setAttribute("transform", `rotate(${rotationDeg})`);
  }

  function deepCopy(sets){
    return sets.map(pts => pts.map(p => ({x:p.x, y:p.y})));
  }

  function alignIndex(cur, tgt){
    const n=cur.length, step=18;
    function score(shift,rev){
      let sum=0;
      for(let i=0;i<n;i+=step){
        const ti = rev ? (((shift-i)%n+n)%n) : ((i+shift)%n);
        const dx=cur[i].x - tgt[ti].x, dy=cur[i].y - tgt[ti].y;
        sum += dx*dx + dy*dy;
      }
      return sum;
    }
    const coarse=28;
    let best={s:Infinity, sh:0, rev:false};
    for(let sh=0; sh<n; sh+=coarse){
      for(const rev of [false,true]){
        const s=score(sh,rev);
        if(s<best.s) best={s,sh,rev};
      }
    }
    for(let d=-coarse; d<=coarse; d++){
      const sh=(best.sh+d+n)%n;
      for(const rev of [false,true]){
        const s=score(sh,rev);
        if(s<best.s) best={s,sh,rev};
      }
    }
    const out=new Array(n);
    for(let i=0;i<n;i++){
      const ti = best.rev ? (((best.sh-i)%n+n)%n) : ((i+best.sh)%n);
      out[i] = {x:tgt[ti].x, y:tgt[ti].y};
    }
    return out;
  }

  function expandByCopyNoOffset(sets, k){
    const out = sets.map(s => s.map(p=>({x:p.x,y:p.y})));
    while(out.length < k){
      let bi=0, barea=-Infinity;
      for(let i=0;i<out.length;i++){
        const a=Math.abs(polygonArea(out[i]));
        if(a>barea){ barea=a; bi=i; }
      }
      out.push(out[bi].map(p=>({x:p.x,y:p.y})));
    }
    return out.slice(0,k);
  }

  function greedyAssign(curSets,tgtSets){
    const curC=curSets.map(centroid), tgtC=tgtSets.map(centroid);
    const used=new Array(curSets.length).fill(false);
    const map=new Array(tgtSets.length).fill(0);
    for(let j=0;j<tgtSets.length;j++){
      let best=-1, bd=Infinity;
      for(let i=0;i<curSets.length;i++){
        if(used[i]) continue;
        const dx=curC[i].x-tgtC[j].x, dy=curC[i].y-tgtC[j].y;
        const d=dx*dx+dy*dy;
        if(d<bd){ bd=d; best=i; }
      }
      if(best<0) best=0;
      used[best]=true;
      map[j]=best;
    }
    return map;
  }

  function reorderByAssignment(curK,tgtK){
    const map=greedyAssign(curK,tgtK);
    const outCur=new Array(tgtK.length);
    for(let j=0;j<tgtK.length;j++) outCur[j]=curK[map[j]];
    return outCur;
  }

  // Used only when converting MULTI-set shapes into a single editable set.
  // (We do NOT use this for "combine to a perfect circle".)
  function combinedBlobFromSets(sets){
    let cx=0, cy=0, count=0;
    for(const s of sets) for(const p of s){ cx+=p.x; cy+=p.y; count++; }
    cx/=count; cy/=count;

    const rays=new Array(POINTS).fill(0);
    for(const s of sets){
      for(const p of s){
        const dx=p.x-cx, dy=p.y-cy;
        const th=Math.atan2(dy,dx);
        let i=Math.floor(((th+Math.PI)/TAU)*POINTS);
        i=(i%POINTS+POINTS)%POINTS;
        const r=Math.hypot(dx,dy);
        if(r>rays[i]) rays[i]=r;
      }
    }
    for(let pass=0;pass<22;pass++){
      const out=rays.slice();
      for(let i=0;i<POINTS;i++){
        const a=rays[(i-1+POINTS)%POINTS], b=rays[i], c=rays[(i+1)%POINTS];
        out[i]=(a+2*b+c)/4;
      }
      for(let i=0;i<POINTS;i++) rays[i]=out[i];
    }
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const th=i/POINTS*TAU - Math.PI;
      const r=rays[i]||BASE_R*.2;
      pts.push({x:cx+r*Math.cos(th), y:cy+r*Math.sin(th)});
    }
    return [pts];
  }

  function render(){
    ensurePaths(currentSets.length);
    for(let i=0;i<currentSets.length;i++){
      group.children[i].setAttribute("d", toSmoothPath(currentSets[i]));
    }
    if(isEditing) updateEditHandles();
  }

  function beginMorph(nextSets, ms, meta){
    const k = Math.max(currentSets.length, nextSets.length);

    const fromK = expandByCopyNoOffset(currentSets, k);
    const toK   = expandByCopyNoOffset(nextSets,   k);

    fromSets = deepCopy(fromK);
    toSets   = deepCopy(toK);

    morphStart = performance.now();
    morphDur = ms;
    morphing = true;
    morphMeta = meta || {type:"same",k};

    setBusy(true);
    start();
  }

  function applyMorphOpacities(tt){
    if(!morphMeta) return;

    const k = morphMeta.k || currentSets.length;

    if(morphMeta.type === "split" && k>1){
      for(let i=0;i<k;i++){
        const o = (i===0) ? 1 : Math.min(1, easeOut(tt*1.4));
        if(group.children[i]) group.children[i].setAttribute("opacity", String(o));
      }
      return;
    }

    if(morphMeta.type === "combine" && k>1){
      const fadeStart = 0.55;
      const fadeT = tt < fadeStart ? 0 : Math.min(1, (tt - fadeStart) / (1 - fadeStart));
      for(let i=0;i<k;i++){
        const o = (i===0) ? 1 : String(1 - easeOut(fadeT));
        if(group.children[i]) group.children[i].setAttribute("opacity", String(o));
      }
    }
  }

  function start(){
    if(raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(tick);
  }

  let last = performance.now();

  function tick(now){
    const dt = Math.min(.033, (now-last)/1000);
    last = now;

    if(zoomAnim){
      const t=(now-zoomAnim.start)/MS_ZOOM;
      if(t>=1){ zoomPct=zoomAnim.to; zoomAnim=null; }
      else zoomPct = lerp(zoomAnim.from, zoomAnim.to, easeOut(Math.max(0,Math.min(1,t))));
      updateWorld();
    }

    if(mode==="blob" && !morphing && !isEditing){
      updateBlobCtrl(dt, now/1000);
      currentSets = blobFromCtrl();
      render();
      raf = requestAnimationFrame(tick);
      return;
    }

    if(morphing){
      const tt = Math.min(1, (now-morphStart)/morphDur);
      const e = easeInOut(tt);

      const k = Math.max(fromSets.length, toSets.length);
      ensurePaths(k);

      const interp = fromSets.map((a,si)=>{
        const b = toSets[si];
        const out = new Array(POINTS);
        for(let i=0;i<POINTS;i++){
          out[i] = { x: lerp(a[i].x, b[i].x, e), y: lerp(a[i].y, b[i].y, e) };
        }
        return out;
      });

      currentSets = interp;
      applyMorphOpacities(tt);

      if(tt>=1){
        morphing=false;
        currentSets = deepCopy(toSets);

        // HARD guarantee: combine ends as ONE item, and uses EXACT target single set
        if(morphMeta && morphMeta.type==="combine" && morphMeta.targetSingleSets){
          currentSets = deepCopy(morphMeta.targetSingleSets);
          toSets = deepCopy(currentSets);
          ensurePaths(1);
          if(group.firstChild) group.firstChild.setAttribute("opacity","1");
        }

        morphMeta = null;
        setBusy(false);
        setOk();
      }
    }

    render();
    raf = requestAnimationFrame(tick);
  }

  function isCssColor(str){
    const s=str.trim();
    if(!s) return false;
    const test=document.createElement("div");
    test.style.color="";
    test.style.color=s;
    return !!test.style.color;
  }

  /* ===== Procedural PERFECT basic shapes ===== */
  function proceduralShape(name){
    const n = name.toLowerCase().trim();
    if(n==="circle"){
      const sets=[makeCirclePoints(BASE_R)];
      normalizeTotal(sets);
      return sets;
    }
    if(n==="oval"){
      const sets=[makeEllipsePoints(BASE_R*1.12, BASE_R*0.78)];
      normalizeTotal(sets);
      return sets;
    }
    if(n==="square"){
      const sets=[makeRegularPolygonPoints(4, BASE_R*1.08)];
      normalizeTotal(sets);
      return sets;
    }
    if(n==="rectangle"){
      const pts=makeEllipsePoints(BASE_R*1.25, BASE_R*0.78);
      const sets=[pts];
      normalizeTotal(sets);
      return sets;
    }
    if(n==="triangle"){
      const sets=[makeRegularPolygonPoints(3, BASE_R*1.18)];
      normalizeTotal(sets);
      return sets;
    }
    if(n==="diamond"){
      const sets=[makeDiamondPoints(BASE_R*1.15)];
      normalizeTotal(sets);
      return sets;
    }
    if(n==="pentagon"){
      const sets=[makeRegularPolygonPoints(5, BASE_R*1.18)];
      normalizeTotal(sets);
      return sets;
    }
    if(n==="hexagon"){
      const sets=[makeRegularPolygonPoints(6, BASE_R*1.18)];
      normalizeTotal(sets);
      return sets;
    }
    return null;
  }

  // ✅ FIXED combine logic: do NOT "combinedBlobFromSets(target)" when target is already a perfect single set
  function buildPlan(current, target){
    const m=current.length, n=target.length;

    if(m===n){
      const aligned = current.map((c,i)=>alignIndex(c, target[i]));
      return { sets: aligned, ms: MS_DIRECT, meta:{type:"same",k:n} };
    }

    const k = Math.max(m,n);
    let curK = expandByCopyNoOffset(current, k);
    let tgtK = expandByCopyNoOffset(target, k);

    normalizeTotal(curK);
    normalizeTotal(tgtK);

    curK = reorderByAssignment(curK, tgtK);
    const alignedTgt = tgtK.map((t,i)=>alignIndex(curK[i], t));

    // combine into 1: animate k paths toward the SINGLE target[0], then drop to 1 path
    if(n===1 && m>1){
      const finalOne = deepCopy(target);   // ✅ exact target (keeps circle perfect)
      normalizeTotal(finalOne);

      const final = finalOne[0];

      const allToFinal = new Array(k).fill(0).map((_,i) => alignIndex(curK[i], final));

      return {
        sets: allToFinal,
        ms: MS_MIX,
        meta:{type:"combine", k, targetSingleSets: finalOne}
      };
    }

    return {
      sets: alignedTgt,
      ms: MS_MIX,
      meta:{type:"split", k}
    };
  }

  /* Export */
  function exportSVGString(){
    const vb="-220 -220 440 440";
    const ds=[...group.children].map(p=>p.getAttribute("d")||"").filter(Boolean);
    const paths=ds.map(d=>`    <path d="${d}" fill="${fillColor}"/>`).join("\n");
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}">
  <g transform="translate(${panX} ${panY}) scale(${zoomPct/100}) rotate(${rotationDeg})">
${paths}
  </g>
</svg>
`;
  }
  function doCopy(){ navigator.clipboard.writeText(exportSVGString()); }
  function doExport(){
    const text=exportSVGString();
    const blob=new Blob([text],{type:"image/svg+xml;charset=utf-8"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url;a.download="shape.svg";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  /* Blob mode */
  const blobCtrl = Array.from({length:BLOB_CTRL},(_,i)=>({r:1,v:0,seed:(i+1)*999.123}));
  function rand01(x){ const s=Math.sin(x)*43758.5453123; return s-Math.floor(s); }
  function updateBlobCtrl(dt,t){
    for(let i=0;i<BLOB_CTRL;i++){
      const c=blobCtrl[i];
      const target=1+.08*Math.sin(t*.55+i*.95)+.04*Math.sin(t*.23+i*1.65);
      const n=(rand01(c.seed+t*.35)-.5)*.16;
      const k=2.8,damp=2.2;
      const a=k*(target+n-c.r)-damp*c.v;
      c.v+=a*dt; c.r+=c.v*dt;
    }
  }
  function catmullRomClosed(ctrlPts,samples){
    const n=ctrlPts.length,out=new Array(samples),get=i=>ctrlPts[(i%n+n)%n];
    for(let s=0;s<samples;s++){
      const tt=s/samples*n,i=Math.floor(tt),u=tt-i,p0=get(i-1),p1=get(i),p2=get(i+1),p3=get(i+2);
      const u2=u*u,u3=u2*u;
      const x=.5*((2*p1.x)+(-p0.x+p2.x)*u+(2*p0.x-5*p1.x+4*p2.x-p3.x)*u2+(-p0.x+3*p1.x-3*p2.x+p3.x)*u3);
      const y=.5*((2*p1.y)+(-p0.y+p2.y)*u+(2*p0.y-5*p1.y+4*p2.y-p3.y)*u2+(-p0.y+3*p1.y-3*p2.y+p3.y)*u3);
      out[s]={x,y};
    }
    return out;
  }
  function blobFromCtrl(){
    const ctrlPts=new Array(BLOB_CTRL);
    for(let i=0;i<BLOB_CTRL;i++){
      const th=i/BLOB_CTRL*TAU, r=BASE_R*blobCtrl[i].r;
      ctrlPts[i]={x:r*Math.cos(th), y:r*Math.sin(th)};
    }
    const pts=catmullRomClosed(ctrlPts,POINTS);
    normalizeTotal([pts]);
    return [pts];
  }

  /* Shapes loading */
  function splitPathData(d){
    if(!d) return [];
    const m=d.match(/[Mm][^Mm]*/g);
    return m ? m.map(s=>s.trim()).filter(Boolean) : [d];
  }
  function parseViewBox(svgEl){
    const vb=svgEl.getAttribute("viewBox");
    if(!vb) return null;
    const parts=vb.trim().split(/[\s,]+/).map(Number);
    if(parts.length!==4||parts.some(x=>!Number.isFinite(x))) return null;
    return {minX:parts[0], minY:parts[1]};
  }
  function clearMeasureGroup(){ while(measureGroup.firstChild) measureGroup.removeChild(measureGroup.firstChild); }
  function samplePathElement(pathEl){
    const L=pathEl.getTotalLength();
    if(!isFinite(L)||L<=0) return null;
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const p=pathEl.getPointAtLength(i/POINTS*L);
      pts.push({x:p.x,y:p.y});
    }
    return pts;
  }

  const cache={}, missing=new Set();
  async function loadShapeByName(name){
    const file=name.toLowerCase().trim().replace(/\s+/g,"-") + ".svg";
    if(missing.has(file)) return null;
    if(cache[file]) return cache[file];
    try{
      const res=await fetch("shapes/"+file,{cache:"force-cache"});
      if(!res.ok){ missing.add(file); return null; }
      const txt=await res.text();
      const doc=new DOMParser().parseFromString(txt,"image/svg+xml");
      const svgEl=doc.querySelector("svg");
      if(!svgEl){ missing.add(file); return null; }
      const paths=[...svgEl.querySelectorAll("path")];
      if(!paths.length){ missing.add(file); return null; }

      clearMeasureGroup();
      const wrap=document.createElementNS("http://www.w3.org/2000/svg","g");
      measureGroup.appendChild(wrap);

      const vb=parseViewBox(svgEl);
      if(vb) wrap.setAttribute("transform",`translate(${-vb.minX} ${-vb.minY})`);

      const sets=[];
      for(const el of paths){
        const d0=el.getAttribute("d");
        if(!d0) continue;
        const parts=splitPathData(d0);
        for(const part of parts){
          const p=document.createElementNS("http://www.w3.org/2000/svg","path");
          p.setAttribute("d",part);
          const tr=el.getAttribute("transform");
          if(tr) p.setAttribute("transform",tr);
          wrap.appendChild(p);
          const pts=samplePathElement(p);
          if(pts) sets.push(pts);
        }
      }
      if(!sets.length){ missing.add(file); return null; }

      normalizeTotal(sets);
      cache[file]=sets;
      return sets;
    }catch{
      missing.add(file);
      return null;
    }
  }

  function pushHistory(name){
    if(history[history.length-1]!==name) history.push(name);
  }

  function stopAuto(){
    if(autoTimer){ clearInterval(autoTimer); autoTimer=null; }
    autoRunning=false;
  }

  async function goBlob(){
    stopAuto();
    exitEdit();
    mode="blob";
    currentName="blob";
    pushHistory("blob");
    setBusy(false);
    setOk();
    start();
  }

  async function applyShape(name,{keepAuto=false}={}){
    const v=name.trim();
    if(!v) return;
    const low=v.toLowerCase();
    if(low===currentName){ setOk(); return; }

    if(!keepAuto) stopAuto();
    exitEdit();

    setBusy(true);

    let sets = proceduralShape(low);
    if(!sets){
      sets = await loadShapeByName(v);
    }

    if(!sets){ setBusy(false); setErr(); return; }

    mode="shape";
    currentName=low;
    pushHistory(low);

    const plan=buildPlan(currentSets, sets);
    beginMorph(plan.sets, plan.ms, plan.meta);
  }

  function chooseRandomOrder(){
    const arr=SHAPES.slice();
    for(let i=arr.length-1;i>0;i--){
      const j=(Math.random()*(i+1))|0;
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  async function randomExisting({keepAuto=false}={}){
    const cur=currentName;
    const order=chooseRandomOrder();
    for(const name of order){
      const low=name.toLowerCase();
      if(low===cur) continue;

      let sets = proceduralShape(low);
      if(!sets) sets = await loadShapeByName(name);
      if(!sets) continue;

      exitEdit();
      if(!keepAuto) stopAuto();

      mode="shape";
      currentName=low;
      pushHistory(low);

      const plan=buildPlan(currentSets, sets);
      beginMorph(plan.sets, plan.ms, plan.meta);
      return true;
    }
    setErr();
    return false;
  }

  function startAuto(){
    stopAuto();
    autoRunning=true;
    randomExisting({keepAuto:true});
    autoTimer=setInterval(()=>{
      if(!autoRunning) return;
      randomExisting({keepAuto:true});
    },5000);
  }

  async function previous(){
    stopAuto();
    if(history.length<=1) return;
    history.pop();
    const prev=history[history.length-1]||"blob";
    if(prev==="blob"){ await goBlob(); return; }
    await applyShape(prev);
  }

  /* Drag / pan (✅ rewritten: stable viewBox-unit panning) */
  function toggleDrag(){
    dragEnabled=!dragEnabled;
    if(dragEnabled && isEditing) exitEdit();
    panLayer.classList.toggle("on", dragEnabled);
    panLayer.style.cursor = dragEnabled ? "grab" : "default";
    dragging=false;
  }

  function viewBoxDeltaFromClientDelta(dxPx, dyPx){
    const rect=svgRoot.getBoundingClientRect();
    const vb=svgRoot.viewBox.baseVal;
    const dxV = dxPx/rect.width * vb.width;
    const dyV = dyPx/rect.height * vb.height;
    return {dxV, dyV};
  }

  function onPanDown(e){
    if(!dragEnabled||isEditing) return;
    dragging=true;
    pointerStart={x:e.clientX,y:e.clientY};
    panStart={x:panX,y:panY};
    panLayer.setPointerCapture?.(e.pointerId);
    panLayer.style.cursor="grabbing";
    e.preventDefault();
  }

  function onPanMove(e){
    if(!dragging) return;
    const dxPx = e.clientX - pointerStart.x;
    const dyPx = e.clientY - pointerStart.y;
    const {dxV,dyV}=viewBoxDeltaFromClientDelta(dxPx,dyPx);
    // panX/panY live in SVG units (before world scale), so just add delta:
    panX = panStart.x + dxV;
    panY = panStart.y + dyV;
    updateWorld();
    start();
    e.preventDefault();
  }

  function onPanUp(){
    dragging=false;
    if(dragEnabled) panLayer.style.cursor="grab";
  }

  panLayer.addEventListener("pointerdown", onPanDown);
  window.addEventListener("pointermove", onPanMove, {passive:false});
  window.addEventListener("pointerup", onPanUp);

  window.addEventListener("wheel", e=>{
    if(isEditing) return;
    const step=Math.sign(e.deltaY)>0 ? -6 : 6;
    animateZoomTo(zoomPct+step);
    e.preventDefault();
  }, {passive:false});

  /* Modal */
  infoBtn.addEventListener("click", ()=> modal.classList.add("open"));
  closeBtn.addEventListener("click", ()=> modal.classList.remove("open"));
  modal.addEventListener("click", e=>{ if(e.target===modal) modal.classList.remove("open"); });
  window.addEventListener("keydown", e=>{ if(e.key==="Escape") modal.classList.remove("open"); });

  /* Commands */
  cmd.addEventListener("keydown", async e=>{
    if(e.key!=="Enter") return;
    const raw=cmd.value.trim();
    if(!raw){ await goBlob(); return; }

    const lower=raw.toLowerCase();
    if(lower==="blob"){ await goBlob(); return; }
    if(lower==="copy"){ doCopy(); setOk(); return; }
    if(lower==="export"){ doExport(); setOk(); return; }
    if(lower==="random"){ await randomExisting(); return; }
    if(lower==="randomize"){ startAuto(); setOk(); return; }
    if(lower==="stoprandom"){ stopAuto(); setOk(); return; }
    if(lower==="previous"){ await previous(); return; }
    if(lower==="drag"){ toggleDrag(); setOk(); return; }
    if(lower.startsWith("zoom ")){ setZoom(lower.slice(5).trim()); setOk(); return; }
    if(lower.startsWith("rotate ")){
      const n=parseFloat(raw.slice(7).trim());
      if(Number.isFinite(n)) setRotation(rotationDeg+n);
      setOk(); return;
    }
    if(isCssColor(raw)){ setFill(raw); setOk(); return; }
    if(lower==="edit"){ toggleEdit(); setOk(); return; }

    await applyShape(raw);
  });

  /* Edit mode: soft selection point dragging (✅ more Illustrator-ish) */
  let handles=[], dragH=-1, dragHStart=null, origPts=null;

  function svgPointFromClient(clientX,clientY){
    const pt=svgRoot.createSVGPoint();
    pt.x=clientX; pt.y=clientY;
    const ctm=svgRoot.getScreenCTM();
    if(!ctm) return {x:0,y:0};
    const inv=ctm.inverse();
    const p=pt.matrixTransform(inv);
    return {x:p.x, y:p.y};
  }

  function clearEdit(){ while(editLayer.firstChild) editLayer.removeChild(editLayer.firstChild); }

  function buildHandle(i){
    const g=document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("class","handle");
    g.dataset.i=String(i);

    const o=document.createElementNS("http://www.w3.org/2000/svg","circle");
    o.setAttribute("r","6.4");
    o.setAttribute("class","handleOutline");
    g.appendChild(o);

    const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("r","4.4");
    c.setAttribute("class","handleCore");
    g.appendChild(c);

    const r=document.createElementNS("http://www.w3.org/2000/svg","circle");
    r.setAttribute("r","8.2");
    r.setAttribute("class","handleRing");
    g.appendChild(r);

    return g;
  }

  function smartIdx(pts,limit){
    const n=pts.length;
    const step=Math.max(1,Math.floor(n/limit));
    const idxs=[];
    for(let i=0;i<n;i+=step) idxs.push(i);
    const uniq=[...new Set(idxs.map(i=>((i%n)+n)%n))].sort((a,b)=>a-b);
    return uniq.slice(0,Math.min(limit,uniq.length));
  }

  function rebuildHandles(){
    clearEdit();
    handles=[];
    const pts=currentSets[0];
    const idxs=smartIdx(pts,72);
    for(const idx of idxs) handles.push({idx,node:null});
    for(let i=0;i<handles.length;i++){
      const node=buildHandle(i);
      handles[i].node=node;
      editLayer.appendChild(node);
    }
    updateEditHandles();
  }

  function updateEditHandles(){
    if(!isEditing) return;
    for(let i=0;i<handles.length;i++){
      const h=handles[i];
      const p=currentSets[0][h.idx];
      h.node.setAttribute("transform",`translate(${fmt(p.x)} ${fmt(p.y)})`);
    }
  }

  function softWeight(d, r){
    if(d>=r) return 0;
    const t = 1 - (d/r);
    return Math.pow(t, EDIT_SOFT_POWER);
  }

  function onHandleDown(e){
    const t=e.target.closest?.(".handle");
    if(!t) return;

    dragH = Number(t.dataset.i);
    dragHStart = svgPointFromClient(e.clientX, e.clientY);

    // snapshot all points (so deformation is stable while dragging)
    origPts = currentSets[0].map(p => ({x:p.x,y:p.y}));

    t.setPointerCapture?.(e.pointerId);

    e.preventDefault();
    e.stopPropagation();
  }

  function onHandleMove(e){
    if(!isEditing || dragH<0) return;

    const p = svgPointFromClient(e.clientX, e.clientY);
    const dx = p.x - dragHStart.x;
    const dy = p.y - dragHStart.y;

    const idx = handles[dragH].idx;

    // base point in snapshot
    const base = origPts[idx];

    // apply soft selection around dragged point
    const pts = currentSets[0];
    for(let i=0;i<pts.length;i++){
      const o = origPts[i];
      const ddx = o.x - base.x;
      const ddy = o.y - base.y;
      const dist = Math.hypot(ddx, ddy);
      const w = (i===idx) ? 1 : softWeight(dist, EDIT_SOFT_RADIUS);
      pts[i].x = o.x + dx*w;
      pts[i].y = o.y + dy*w;
    }

    // keep size consistent, but don't "snap" too hard: normalize + re-center only
    normalizeTotal(currentSets);

    render();
    start();

    e.preventDefault();
  }

  function onHandleUp(){
    dragH=-1;
    dragHStart=null;
    origPts=null;
  }

  function enterEdit(){
    stopAuto();
    if(isEditing) return;

    isEditing=true;
    document.body.classList.add("editing");

    // ✅ FIX: do NOT rebuild single-set shapes (keeps circle perfect)
    // If we're in blob mode, convert the blob to a single editable set.
    if(mode==="blob"){
      mode="shape";
      currentName="custom";
      currentSets = combinedBlobFromSets(currentSets);
      normalizeTotal(currentSets);
      pushHistory("custom");
    }

    // If current shape has multiple sets, flatten to one (reasonable for editing)
    if(currentSets.length > 1){
      currentSets = combinedBlobFromSets(currentSets);
      normalizeTotal(currentSets);
    }

    // Ensure exactly 1 set for edit
    currentSets = [ currentSets[0].map(p=>({x:p.x,y:p.y})) ];
    normalizeTotal(currentSets);

    rebuildHandles();

    svgRoot.addEventListener("pointerdown", onHandleDown);
    window.addEventListener("pointermove", onHandleMove, {passive:false});
    window.addEventListener("pointerup", onHandleUp);

    // turn off pan layer while editing
    if(dragEnabled){
      dragEnabled=false;
      panLayer.classList.remove("on");
      panLayer.style.cursor="default";
      dragging=false;
    }

    start();
  }

  function exitEdit(){
    if(!isEditing) return;
    isEditing=false;
    document.body.classList.remove("editing");

    svgRoot.removeEventListener("pointerdown", onHandleDown);
    window.removeEventListener("pointermove", onHandleMove);
    window.removeEventListener("pointerup", onHandleUp);

    clearEdit();
  }

  function toggleEdit(){ isEditing ? exitEdit() : enterEdit(); }

  function init(){
    setFill("#ffffff");
    setRotation(0);
    updateWorld();
    cmd.classList.add("ok");
    goBlob();
  }
  init();
})();
</script>
</body>
</html>

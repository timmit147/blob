<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blob → Shape (multi-path)</title>

<style>
:root{
  --bg:#0b0f19;
  --fg:#e9eefc;
  --ui:rgba(255,255,255,.08);
  --ui-b:rgba(255,255,255,.14);
}
html,body{height:100%;margin:0}
body{
  background:radial-gradient(1200px 700px at 50% 40%,#151d33 0%,var(--bg) 60%,#070a12 100%);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--fg);
  overflow:hidden;
}

/* center */
.stage{
  position:fixed;
  inset:0;
  display:grid;
  place-items:center;
  pointer-events:none;
}
svg{
  width:min(520px,86vw);
  height:auto;
  filter:drop-shadow(0 18px 40px rgba(0,0,0,.55));
}

/* input */
.bottom{
  position:fixed;
  left:50%;
  bottom:22px;
  transform:translateX(-50%);
  width:min(720px,92vw);
  pointer-events:auto;
}
.bottom input{
  width:100%;
  padding:14px 16px;
  border-radius:14px;
  border:1px solid var(--ui-b);
  background:var(--ui);
  color:var(--fg);
  outline:none;
  font-size:16px;
}

/* toolbar */
.toolbar{
  position:fixed;
  top:14px;
  right:14px;
  display:flex;
  gap:10px;
  align-items:center;
  pointer-events:auto;
}
.btn{
  border:1px solid var(--ui-b);
  background:var(--ui);
  color:var(--fg);
  border-radius:12px;
  padding:10px 12px;
  font-size:14px;
  cursor:pointer;
}
.btn:hover{background:rgba(255,255,255,.12)}

/* color */
.color{ position:relative; }
.color-dot{
  width:32px;height:32px;
  border-radius:50%;
  border:1px solid var(--ui-b);
  cursor:pointer;
}
.color-panel{
  position:absolute;
  top:40px;
  right:0;
  background:rgba(10,14,25,.95);
  border:1px solid var(--ui-b);
  border-radius:12px;
  padding:10px;
  display:none;
  gap:8px;
}
.color-panel.open{display:flex}
.color-panel input[type="color"]{width:42px;height:32px;border:none;background:none}
.color-panel input[type="text"]{
  width:120px;
  background:var(--ui);
  border:1px solid var(--ui-b);
  color:var(--fg);
  border-radius:8px;
  padding:6px 8px;
}

/* rotate */
.rotate{display:flex;align-items:center;gap:6px}
.rotate input{width:80px}
</style>
</head>

<body>

<div class="toolbar">
  <div class="color">
    <div id="colorDot" class="color-dot"></div>
    <div id="colorPanel" class="color-panel">
      <input id="colorPicker" type="color" value="#ffffff"/>
      <input id="colorText" type="text" value="#ffffff"/>
    </div>
  </div>

  <div class="rotate" title="Rotate">
    <span>↻</span>
    <input id="rotateRange" type="range" min="0" max="360" value="0"/>
  </div>

  <button id="exportBtn" class="btn">Export</button>
  <button id="copyBtn" class="btn">Copy</button>
</div>

<div class="stage">
  <svg id="svgRoot" viewBox="-220 -220 440 440" xmlns="http://www.w3.org/2000/svg">
    <g id="shapeGroup"></g>
    <path id="helperPath" fill="none" stroke="none" visibility="hidden"/>
  </svg>
</div>

<div class="bottom">
  <input id="cmd" placeholder="type shape name (empty = blob)"/>
</div>

<script>
(() => {
  const TAU = Math.PI * 2;
  const lerp = (a,b,t)=>a+(b-a)*t;

  const POINTS = 120;
  const BASE_R = 140;

  const group = document.getElementById("shapeGroup");
  const helper = document.getElementById("helperPath");
  const cmd = document.getElementById("cmd");

  const colorDot = document.getElementById("colorDot");
  const colorPanel = document.getElementById("colorPanel");
  const colorPicker = document.getElementById("colorPicker");
  const colorText = document.getElementById("colorText");

  const rotateRange = document.getElementById("rotateRange");

  let fillColor = "#ffffff";
  let mode = "blob"; // blob | shape
  let raf = null, last = performance.now(), time = 0;

  // Multi-path state
  // currentSets[i] = array of points for path i
  let currentSets = [makeBlobPoints()];
  let targetSets  = [makeBlobPoints()];
  let frozenDs = []; // one d per path when frozen

  // organic blob phases
  const blobPhase = Array.from({length: POINTS}, (_, i) => {
    const th = (i / POINTS) * TAU;
    return 3.1*Math.sin(th*2.7+1.2) + 2.0*Math.sin(th*1.3-0.5);
  });

  function makeBlobPoints(){
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const th=(i/POINTS)*TAU;
      const r=BASE_R*(1
        +0.16*Math.sin(th*2+0.8)
        +0.10*Math.sin(th*3-1.4)
        +0.07*Math.sin(th*5+2.2)
      );
      pts.push({x:r*Math.cos(th), y:r*Math.sin(th)});
    }
    return pts;
  }

  // Catmull-Rom-ish smoothing path
  function toPath(pts){
    const n = pts.length;
    const p = (i)=>pts[(i+n)%n];
    let d="";
    for(let i=0;i<n;i++){
      const p0=p(i-1), p1=p(i), p2=p(i+1), p3=p(i+2);
      const c1x = p1.x + (p2.x - p0.x)/6;
      const c1y = p1.y + (p2.y - p0.y)/6;
      const c2x = p2.x - (p3.x - p1.x)/6;
      const c2y = p2.y - (p3.y - p1.y)/6;
      if(i===0) d += `M ${p1.x.toFixed(2)} ${p1.y.toFixed(2)} `;
      d += `C ${c1x.toFixed(2)} ${c1y.toFixed(2)}, ${c2x.toFixed(2)} ${c2y.toFixed(2)}, ${p2.x.toFixed(2)} ${p2.y.toFixed(2)} `;
    }
    return d + "Z";
  }

  function centroid(pts){
    let cx=0, cy=0;
    for(const p of pts){ cx+=p.x; cy+=p.y; }
    return {x: cx/pts.length, y: cy/pts.length};
  }

  // Normalize multiple path point sets together:
  // - keep relative positions (pause bars stay apart)
  // - center overall to origin
  // - scale so max radius fits BASE_R
  function normalizeMulti(sets){
    // flatten
    const all=[];
    for(const pts of sets) for(const p of pts) all.push(p);

    // center overall
    let cx=0, cy=0;
    for(const p of all){ cx+=p.x; cy+=p.y; }
    cx/=all.length; cy/=all.length;

    for(const pts of sets){
      for(const p of pts){
        p.x -= cx; p.y -= cy;
      }
    }

    // scale by max radius
    let maxR = 0;
    for(const pts of sets){
      for(const p of pts){
        maxR = Math.max(maxR, Math.hypot(p.x, p.y));
      }
    }
    const s = maxR > 0 ? (BASE_R / maxR) : 1;
    for(const pts of sets){
      for(const p of pts){
        p.x *= s; p.y *= s;
      }
    }
    return sets;
  }

  function pointsFromPathD(d){
    helper.setAttribute("d", d);
    const L = helper.getTotalLength();
    if(!isFinite(L) || L <= 0) return null;
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const p = helper.getPointAtLength((i/POINTS) * L);
      pts.push({x:p.x, y:p.y});
    }
    return pts;
  }

  // Render paths: ensure group has N <path> elements
  function ensurePathEls(n){
    while(group.children.length < n){
      const p = document.createElementNS("http://www.w3.org/2000/svg","path");
      p.setAttribute("fill", fillColor);
      group.appendChild(p);
    }
    while(group.children.length > n){
      group.removeChild(group.lastChild);
    }
    // keep fill synced
    for(const el of group.children){
      el.setAttribute("fill", fillColor);
    }
  }

  function setFill(c){
    fillColor = c;
    colorDot.style.background = c;
    for(const el of group.children){
      el.setAttribute("fill", c);
    }
  }

  // Animation control
  function start(){
    if(raf) cancelAnimationFrame(raf);
    last = performance.now();
    raf = requestAnimationFrame(tick);
  }

  function tick(now){
    const dt = (now-last)/1000;
    last = now;
    time += dt;

    // Smooth morph
    const alpha = 1 - Math.exp(-2.6 * dt);

    let done = true;

    // morph every set
    for(let s=0; s<currentSets.length; s++){
      const a = currentSets[s];
      const b = targetSets[s];
      for(let i=0;i<POINTS;i++){
        const nx = lerp(a[i].x, b[i].x, alpha);
        const ny = lerp(a[i].y, b[i].y, alpha);
        if(Math.hypot(nx-b[i].x, ny-b[i].y) > 0.03) done = false;
        a[i].x = nx; a[i].y = ny;
      }
    }

    // render sets
    ensurePathEls(currentSets.length);

    frozenDs = [];
    for(let s=0; s<currentSets.length; s++){
      let renderPts = currentSets[s];

      if(mode === "blob"){
        // wobble per set too
        renderPts = currentSets[s].map((p,i)=>{
          const r = Math.hypot(p.x,p.y);
          const th = Math.atan2(p.y,p.x);
          const wobble =
            1
            + 0.085*Math.sin(time*2.0 + blobPhase[i] + s*0.7)
            + 0.045*Math.sin(time*3.1 + blobPhase[i]*0.7 + s*0.5);
          return { x: r*wobble*Math.cos(th), y: r*wobble*Math.sin(th) };
        });
      }

      const d = toPath(renderPts);
      group.children[s].setAttribute("d", d);
      frozenDs.push(d);
    }

    if(mode === "shape" && done){
      // freeze perfectly: stop animating
      raf = null;
      return;
    }

    raf = requestAnimationFrame(tick);
  }

  // Load shape from /shapes (supports multiple <path>)
  const cache = {};
  async function loadShape(name){
    const file = name.toLowerCase().trim().replace(/\s+/g,"-") + ".svg";
    if(cache[file]) return cache[file];

    try{
      const res = await fetch("shapes/" + file);
      if(!res.ok) return null;
      const txt = await res.text();
      const doc = new DOMParser().parseFromString(txt, "image/svg+xml");

      const paths = [...doc.querySelectorAll("path")];
      if(!paths.length) return null;

      const sets = [];
      for(const p of paths){
        const d = p.getAttribute("d");
        if(!d) continue;
        const pts = pointsFromPathD(d);
        if(pts) sets.push(pts);
      }
      if(!sets.length) return null;

      // normalize all together (keeps separation like pause bars)
      const normalized = normalizeMulti(sets);

      cache[file] = normalized;
      return normalized;
    } catch {
      return null;
    }
  }

  // When switching to a shape with N paths, we want N blobs as starting state
  // that are already roughly placed where the targets are.
  function spawnFromTargets(targetSetsIn){
    // create same count blob sets
    const spawned = targetSetsIn.map((tset, idx)=>{
      // base blob
      const b = makeBlobPoints();

      // align blob's center near target center (after normalization, centroid matters)
      const ct = centroid(tset);
      const cb = centroid(b);

      // shift blob to target centroid
      for(const p of b){
        p.x = (p.x - cb.x) + ct.x;
        p.y = (p.y - cb.y) + ct.y;
      }
      return b;
    });

    // Keep the whole pack centered/scaled similarly
    return normalizeMulti(spawned);
  }

  // Input logic: no enter needed
  let lastName = "";
  cmd.addEventListener("input", async () => {
    const v = cmd.value.trim();

    if(!v){
      lastName = "";
      mode = "blob";
      currentSets = [makeBlobPoints()];
      targetSets  = [makeBlobPoints()];
      normalizeMulti(currentSets);
      normalizeMulti(targetSets);
      start();
      return;
    }

    if(v === lastName) return;

    const shapeSets = await loadShape(v);
    if(shapeSets){
      lastName = v;
      mode = "shape";

      // If path count changes, respawn currentSets as multiple blobs
      if(currentSets.length !== shapeSets.length){
        currentSets = spawnFromTargets(shapeSets);
      }

      targetSets = shapeSets.map(pts => pts.map(p => ({x:p.x,y:p.y}))); // deep copy
      start();
    }
    // if not found: do nothing (keeps current)
  });

  // Color UI (hidden)
  function setColorUI(c){
    setFill(c);
    colorText.value = c;
    // update picker only for hex
    if(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(c)){
      colorPicker.value = (c.length===4)
        ? "#" + c.slice(1).split("").map(ch=>ch+ch).join("")
        : c;
    }
  }

  setColorUI("#ffffff");

  colorDot.onclick = () => colorPanel.classList.toggle("open");
  colorPicker.oninput = () => setColorUI(colorPicker.value);
  colorText.onchange = () => setColorUI(colorText.value);

  document.addEventListener("click", (e) => {
    if(!colorPanel.contains(e.target) && e.target !== colorDot){
      colorPanel.classList.remove("open");
    }
  });

  // Rotate
  rotateRange.oninput = () => {
    group.setAttribute("transform", `rotate(${rotateRange.value})`);
  };

  // Export / Copy (exports ALL paths)
  function exportSVGString(){
    const rot = rotateRange.value;
    const vb = "-220 -220 440 440";
    const ds = [...group.children].map(p => p.getAttribute("d") || "").filter(Boolean);

    const paths = ds.map(d => `    <path d="${d}" fill="${fillColor}"/>`).join("\n");

    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}">
  <g transform="rotate(${rot})">
${paths}
  </g>
</svg>\n`;
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  document.getElementById("exportBtn").onclick = () => downloadText("shape.svg", exportSVGString());
  document.getElementById("copyBtn").onclick   = () => navigator.clipboard.writeText(exportSVGString());

  // Boot
  normalizeMulti(currentSets);
  normalizeMulti(targetSets);
  start();
})();
</script>

</body>
</html>

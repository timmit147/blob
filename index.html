<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Blob → Shape (Better scaling + Better morph + Better SVG fidelity)</title>

<style>
:root{
  --bg:#0b0f19;
  --fg:#e9eefc;
  --muted:rgba(233,238,252,.68);
  --ui:rgba(255,255,255,.08);
  --ui-b:rgba(255,255,255,.14);
}
html,body{height:100%;margin:0}
body{
  background:radial-gradient(1200px 700px at 50% 40%,#151d33 0%,var(--bg) 60%,#070a12 100%);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--fg);
  overflow:hidden;
}

/* center stage */
.stage{
  position:fixed;
  inset:0;
  display:grid;
  place-items:center;
  pointer-events:none;
}
body.editing .stage{ pointer-events:auto; }

svg{
  width:min(520px,86vw);
  height:auto;
  filter:drop-shadow(0 18px 40px rgba(0,0,0,.55));
}

/* bottom input */
.bottom{
  position:fixed;
  left:50%;
  bottom:22px;
  transform:translateX(-50%);
  width:min(780px,92vw);
  pointer-events:auto;
}
.bottom input{
  width:100%;
  padding:14px 16px;
  border-radius:14px;
  border:1px solid var(--ui-b);
  background:var(--ui);
  color:var(--fg);
  outline:none;
  font-size:16px;
}

/* rotation smooth */
#shapeGroup{
  transition: transform 1800ms cubic-bezier(.2,.9,.2,1);
  transform-origin: 0px 0px;
}
svg path{ transition: fill 600ms ease; }

/* info button: light gray bg, black icon */
.infoBtn{
  position:fixed;
  top:14px;
  right:14px;
  width:38px;
  height:38px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.18);
  background:#d9d9d9;
  color:#000;
  display:grid;
  place-items:center;
  cursor:pointer;
  pointer-events:auto;
  font-weight:800;
}
.infoBtn:hover{background:#e6e6e6}

/* modal */
.modal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  display:none;
  align-items:center;
  justify-content:center;
  pointer-events:auto;
}
.modal.open{display:flex}
.card{
  width:min(860px,92vw);
  background:rgba(10,14,25,.95);
  border:1px solid var(--ui-b);
  border-radius:16px;
  padding:16px;
  box-shadow:0 18px 60px rgba(0,0,0,.6);
}
.card h3{margin:0 0 10px;font-size:16px}
.card p{margin:8px 0;color:var(--muted);font-size:14px;line-height:1.45}
.grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:12px;
  margin-top:12px;
}
.box{
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.05);
  border-radius:12px;
  padding:10px;
}
.box h4{margin:0 0 8px;font-size:14px;color:var(--fg)}
.list{
  margin:0;
  padding-left:18px;
  color:var(--muted);
  font-size:14px;
  line-height:1.45;
}
code{
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.12);
  padding:2px 6px;
  border-radius:8px;
  color:var(--fg);
  font-size:13px;
}
.actions{
  display:flex;
  justify-content:flex-end;
  margin-top:12px;
}
.btn{
  border:1px solid var(--ui-b);
  background:var(--ui);
  color:var(--fg);
  border-radius:12px;
  padding:10px 12px;
  font-size:14px;
  cursor:pointer;
}
.btn:hover{background:rgba(255,255,255,.12)}

/* Edit handles */
#editLayer{ display:none; }
body.editing #editLayer{ display:block; }

.handle{
  cursor:grab;
  pointer-events:auto;
}
body.editing .handle:active{ cursor:grabbing; }
.handleOutline{ fill:rgba(0,0,0,.25); }
.handleCore{ fill:rgba(255,255,255,.95); }
.handleRing{
  fill:none;
  stroke:rgba(255,255,255,.35);
  stroke-width:1.5;
}
</style>
</head>

<body>

<button class="infoBtn" id="infoBtn" aria-label="Info">i</button>

<div class="stage">
  <svg id="svgRoot" viewBox="-220 -220 440 440" xmlns="http://www.w3.org/2000/svg">
    <g id="shapeGroup"></g>
    <g id="editLayer"></g>

    <!-- measurement group (hidden) for accurate transforms/viewBox handling -->
    <g id="measureGroup" visibility="hidden"></g>
  </svg>
</div>

<div class="bottom">
  <input id="cmd" placeholder="type shape name or command (random, edit, copy, export, rotate 90, red...)" autocomplete="off" spellcheck="false"/>
</div>

<div class="modal" id="modal" role="dialog" aria-modal="true">
  <div class="card">
    <h3>Info</h3>
    <p>
      Type a shape name that exists in your <code>/shapes</code> folder (e.g. <code>heart</code>, <code>triangle</code>).
      Press <b>Enter</b> to run commands. Clearing the input returns to blob mode.
    </p>

    <div class="grid">
      <div class="box">
        <h4>Commands (press Enter)</h4>
        <ul class="list">
          <li><code>random</code> — choose a random shape (never repeats current)</li>
          <li><code>edit</code> — toggle edit mode (drag points to make your own shape)</li>
          <li><code>copy</code> — copy current SVG</li>
          <li><code>export</code> — download SVG</li>
          <li><code>rotate 180</code> — rotate relative (smooth)</li>
          <li><code>red</code> / <code>#86c5e4</code> / <code>rgb(10,20,30)</code> — change color</li>
        </ul>
        <p style="margin:10px 0 0;color:var(--muted);font-size:13px">
          Note: command text stays in the input so you can hit Enter again.
        </p>
      </div>

      <div class="box">
        <h4>Shapes list (edit in code)</h4>
        <p style="margin:0 0 8px;color:var(--muted);font-size:13px">
          This list is shown here for convenience (browsers can’t auto-list your folder).
        </p>
        <ul class="list" id="shapeList"></ul>
      </div>
    </div>

    <div class="actions">
      <button class="btn" id="closeBtn">Close</button>
    </div>
  </div>
</div>

<script>
(() => {
  const TAU = Math.PI * 2;
  const lerp = (a,b,t)=>a+(b-a)*t;
  const fmt = (n)=>Number(n).toFixed(3);

  // ====== Edit this list to match what you put in /shapes ======
  const SHAPES = [
    "circle","oval","triangle","square","rectangle","diamond",
    "pentagon","hexagon","star","heart","lightning bolt",
    "plus","cross","check","close","menu","search","home","user",
    "play","pause","stop","download","upload","arrow up","arrow right","chevron",
    "capsule","drop","trapezoid","parallelogram","settings","notification","netherlands"
  ];

  // Geometry fidelity
  const POINTS = 420;        // more points = better coastline/complex shapes
  const BASE_R = 140;

  // Scaling target: use AREA so all shapes feel same size (fixes Netherlands small)
  const TARGET_AREA = Math.PI * BASE_R * BASE_R * 0.92; // tuned to feel "full" but not clipped

  // Slow smooth morph
  const MORPH_MS_SHAPE = 2600;
  const MORPH_MS_BLOB  = 2600;
  const ROTATE_MS = 1800;

  // Blob (smooth random-walk control radii)
  const BLOB_CTRL = 22;

  // Edit handles
  const EDIT_CTRL = 24;

  const svgRoot = document.getElementById("svgRoot");
  const group  = document.getElementById("shapeGroup");
  const editLayer = document.getElementById("editLayer");
  const measureGroup = document.getElementById("measureGroup");

  const cmd    = document.getElementById("cmd");
  const infoBtn  = document.getElementById("infoBtn");
  const modal    = document.getElementById("modal");
  const closeBtn = document.getElementById("closeBtn");
  const shapeListEl = document.getElementById("shapeList");

  SHAPES.forEach(s => {
    const li = document.createElement("li");
    li.textContent = s;
    shapeListEl.appendChild(li);
  });

  let fillColor = "#ffffff";
  let rotationDeg = 0;

  // label so random never repeats
  let currentShapeName = ""; // "" = blob, otherwise shape name or "custom"

  let mode = "blob";         // blob | shape
  let raf = null;

  // rendering mode:
  // - loaded SVG shapes: use poly path (keeps silhouette identical; avoids over-smoothing coastlines)
  // - blob/custom: use smooth cubic
  let renderStyle = "smooth"; // "smooth" | "poly"

  // tween state
  let morphing = false;
  let morphStart = 0;
  let morphDur = MORPH_MS_SHAPE;
  let fromSets = null;
  let toSets = null;

  // Always render this
  let currentSets = [makeCirclePoints(BASE_R)];

  function easeInOutCubic(t){
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;
  }

  // --------------------------
  // Geometry helpers
  // --------------------------
  function makeCirclePoints(r){
    const pts=[];
    for(let i=0;i<POINTS;i++){
      const th = (i/POINTS)*TAU;
      pts.push({x:r*Math.cos(th), y:r*Math.sin(th)});
    }
    return pts;
  }

  function centroid(pts){
    let cx=0, cy=0;
    for(const p of pts){ cx+=p.x; cy+=p.y; }
    return {x:cx/pts.length, y:cy/pts.length};
  }

  function stabilizeCenter(sets){
    let cx=0, cy=0, count=0;
    for(const pts of sets){
      for(const p of pts){ cx+=p.x; cy+=p.y; count++; }
    }
    cx/=count; cy/=count;
    for(const pts of sets){
      for(const p of pts){ p.x-=cx; p.y-=cy; }
    }
  }

  function maxRadius(sets){
    let m=0;
    for(const pts of sets){
      for(const p of pts){ m=Math.max(m, Math.hypot(p.x,p.y)); }
    }
    return m;
  }

  function polygonArea(pts){
    // signed area
    let a=0;
    for(let i=0;i<pts.length;i++){
      const p=pts[i], q=pts[(i+1)%pts.length];
      a += p.x*q.y - q.x*p.y;
    }
    return a * 0.5;
  }

  function totalAreaAbs(sets){
    // if multiple paths, sum abs areas
    let sum=0;
    for(const pts of sets){
      sum += Math.abs(polygonArea(pts));
    }
    return sum;
  }

  function scaleSets(sets, s){
    for(const pts of sets){
      for(const p of pts){ p.x*=s; p.y*=s; }
    }
  }

  function normalizeSizeAndCenterByArea(sets){
    // 1) center
    stabilizeCenter(sets);

    // 2) scale by area to TARGET_AREA
    const a = totalAreaAbs(sets);
    const sArea = (a > 1e-6) ? Math.sqrt(TARGET_AREA / a) : 1;
    scaleSets(sets, sArea);

    // 3) safety clamp: avoid huge spikes clipping outside view
    const m = maxRadius(sets);
    if(m > BASE_R){
      scaleSets(sets, (BASE_R / m) * 0.985);
    }

    // 4) re-center
    stabilizeCenter(sets);
  }

  // Reorder points by angle around centroid, then resample evenly in angle space.
  // This makes “complex outline -> heart” morph much nicer.
  function reorderByAngleAndResample(pts){
    const c = centroid(pts);

    const arr = pts.map(p => {
      const ang = Math.atan2(p.y - c.y, p.x - c.x);
      return {x:p.x, y:p.y, a:ang};
    }).sort((u,v)=>u.a - v.a);

    // close the loop in angle space
    const A = arr.map(v => v.a);
    const P = arr.map(v => ({x:v.x,y:v.y}));

    // unwrap angles for interpolation
    for(let i=1;i<A.length;i++){
      while(A[i] < A[i-1]) A[i] += TAU;
    }

    // duplicate first point at end with angle + TAU to wrap cleanly
    A.push(A[0] + TAU);
    P.push({x:P[0].x,y:P[0].y});

    const out = new Array(POINTS);
    for(let i=0;i<POINTS;i++){
      const tAng = A[0] + (i/POINTS)*TAU;

      // find segment
      let j=0;
      while(j < A.length-1 && A[j+1] < tAng) j++;

      const a0=A[j], a1=A[j+1];
      const u = (a1-a0) > 1e-9 ? (tAng-a0)/(a1-a0) : 0;

      out[i] = {
        x: lerp(P[j].x, P[j+1].x, u),
        y: lerp(P[j].y, P[j+1].y, u),
      };
    }

    return out;
  }

  // --------------------------
  // Path renderers
  // --------------------------
  function toSmoothPath(pts){
    const n = pts.length;
    const p = (i)=>pts[(i+n)%n];
    let d="";
    for(let i=0;i<n;i++){
      const p0=p(i-1), p1=p(i), p2=p(i+1), p3=p(i+2);
      const c1x = p1.x + (p2.x - p0.x)/6;
      const c1y = p1.y + (p2.y - p0.y)/6;
      const c2x = p2.x - (p3.x - p1.x)/6;
      const c2y = p2.y - (p3.y - p1.y)/6;
      if(i===0) d += `M ${fmt(p1.x)} ${fmt(p1.y)} `;
      d += `C ${fmt(c1x)} ${fmt(c1y)}, ${fmt(c2x)} ${fmt(c2y)}, ${fmt(p2.x)} ${fmt(p2.y)} `;
    }
    return d + "Z";
  }

  function toPolyPath(pts){
    let d = `M ${fmt(pts[0].x)} ${fmt(pts[0].y)} `;
    for(let i=1;i<pts.length;i++){
      d += `L ${fmt(pts[i].x)} ${fmt(pts[i].y)} `;
    }
    return d + "Z";
  }

  function ensurePathEls(n){
    while(group.children.length < n){
      const p = document.createElementNS("http://www.w3.org/2000/svg","path");
      p.setAttribute("fill", fillColor);
      group.appendChild(p);
    }
    while(group.children.length > n){
      group.removeChild(group.lastChild);
    }
    for(const el of group.children) el.setAttribute("fill", fillColor);
  }

  function setFill(c){
    fillColor = c;
    for(const el of group.children) el.setAttribute("fill", c);
  }

  function setRotation(deg){
    rotationDeg = deg;
    group.style.transitionDuration = ROTATE_MS + "ms";
    group.setAttribute("transform", `rotate(${rotationDeg})`);
  }

  function deepCopySets(sets){
    return sets.map(pts => pts.map(p => ({x:p.x,y:p.y})));
  }

  // --------------------------
  // Better matching (less twist)
  // --------------------------
  function alignTargetToCurrent(currentPts, targetPts){
    const n = currentPts.length;
    const step = 10;

    function scoreFor(shift, reversed){
      let sum = 0;
      for(let i=0;i<n;i+=step){
        const ti = reversed ? (((shift - i) % n + n) % n) : ((i + shift) % n);
        const dx = currentPts[i].x - targetPts[ti].x;
        const dy = currentPts[i].y - targetPts[ti].y;
        sum += dx*dx + dy*dy;
      }
      return sum;
    }

    const coarseStep = 18;
    let bestShift = 0, bestRev = false, bestScore = Infinity;

    for(let sh=0; sh<n; sh+=coarseStep){
      for(const rev of [false,true]){
        const sc = scoreFor(sh, rev);
        if(sc < bestScore){
          bestScore = sc;
          bestShift = sh;
          bestRev = rev;
        }
      }
    }

    for(let d=-coarseStep; d<=coarseStep; d++){
      const sh = (bestShift + d + n) % n;
      for(const rev of [false,true]){
        const sc = scoreFor(sh, rev);
        if(sc < bestScore){
          bestScore = sc;
          bestShift = sh;
          bestRev = rev;
        }
      }
    }

    const out = new Array(n);
    for(let i=0;i<n;i++){
      const ti = bestRev ? (((bestShift - i) % n + n) % n) : ((i + bestShift) % n);
      out[i] = {x: targetPts[ti].x, y: targetPts[ti].y};
    }
    return out;
  }

  // --------------------------
  // Blob (smooth, stable)
  // --------------------------
  const blobCtrl = Array.from({length:BLOB_CTRL}, (_,i)=>({
    r: 1.0,
    v: 0.0,
    seed: (i+1)*999.123
  }));

  function rand01(x){
    const s = Math.sin(x) * 43758.5453123;
    return s - Math.floor(s);
  }

  function updateBlob(dt, t){
    for(let i=0;i<BLOB_CTRL;i++){
      const c = blobCtrl[i];
      const target =
        1.0
        + 0.075*Math.sin(t*0.50 + i*0.95)
        + 0.035*Math.sin(t*0.22 + i*1.65);

      const n = (rand01(c.seed + t*0.32) - 0.5) * 0.14;

      const k = 2.7;
      const damp = 2.1;

      const a = k*(target + n - c.r) - damp*c.v;
      c.v += a * dt;
      c.r += c.v * dt;
    }
  }

  function catmullRomClosed(ctrlPts, samples){
    const n = ctrlPts.length;
    const out = new Array(samples);
    const get = (i)=>ctrlPts[(i % n + n) % n];

    for(let s=0;s<samples;s++){
      const t = (s / samples) * n;
      const i = Math.floor(t);
      const u = t - i;

      const p0 = get(i-1);
      const p1 = get(i);
      const p2 = get(i+1);
      const p3 = get(i+2);

      const u2 = u*u, u3 = u2*u;

      const x = 0.5 * (
        (2*p1.x) +
        (-p0.x + p2.x)*u +
        (2*p0.x - 5*p1.x + 4*p2.x - p3.x)*u2 +
        (-p0.x + 3*p1.x - 3*p2.x + p3.x)*u3
      );
      const y = 0.5 * (
        (2*p1.y) +
        (-p0.y + p2.y)*u +
        (2*p0.y - 5*p1.y + 4*p2.y - p3.y)*u2 +
        (-p0.y + 3*p1.y - 3*p2.y + p3.y)*u3
      );

      out[s] = {x,y};
    }
    return out;
  }

  function blobPointsFromCtrl(){
    const ctrlPts = new Array(BLOB_CTRL);
    for(let i=0;i<BLOB_CTRL;i++){
      const th = (i/BLOB_CTRL)*TAU;
      const r = BASE_R * blobCtrl[i].r;
      ctrlPts[i] = {x:r*Math.cos(th), y:r*Math.sin(th)};
    }
    const pts = catmullRomClosed(ctrlPts, POINTS);
    normalizeSizeAndCenterByArea([pts]);
    return pts;
  }

  // --------------------------
  // SVG fidelity: apply transforms + viewBox scale properly
  // --------------------------
  function clearMeasureGroup(){
    while(measureGroup.firstChild) measureGroup.removeChild(measureGroup.firstChild);
  }

  function parseViewBox(svgEl){
    const vb = svgEl.getAttribute("viewBox");
    if(!vb) return null;
    const parts = vb.trim().split(/[\s,]+/).map(Number);
    if(parts.length !== 4 || parts.some(x=>!Number.isFinite(x))) return null;
    return {minX:parts[0], minY:parts[1], w:parts[2], h:parts[3]};
  }

  // Convert non-path SVG shapes to paths (common ones)
  function elementToPathData(el){
    const tag = el.tagName.toLowerCase();
    if(tag === "path") return el.getAttribute("d") || "";

    if(tag === "polygon" || tag === "polyline"){
      const pts = (el.getAttribute("points") || "").trim();
      if(!pts) return "";
      const nums = pts.split(/[\s,]+/).map(Number).filter(n=>Number.isFinite(n));
      if(nums.length < 4) return "";
      let d = `M ${nums[0]} ${nums[1]} `;
      for(let i=2;i<nums.length;i+=2){
        d += `L ${nums[i]} ${nums[i+1]} `;
      }
      if(tag === "polygon") d += "Z";
      return d;
    }

    if(tag === "rect"){
      const x = Number(el.getAttribute("x")||0);
      const y = Number(el.getAttribute("y")||0);
      const w = Number(el.getAttribute("width")||0);
      const h = Number(el.getAttribute("height")||0);
      const rx = Number(el.getAttribute("rx")||0);
      const ry = Number(el.getAttribute("ry")||0);
      if(!(w>0 && h>0)) return "";
      if(rx>0 || ry>0){
        const rrx = Math.min(rx||ry, w/2);
        const rry = Math.min(ry||rx, h/2);
        return [
          `M ${x+rrx} ${y}`,
          `L ${x+w-rrx} ${y}`,
          `A ${rrx} ${rry} 0 0 1 ${x+w} ${y+rry}`,
          `L ${x+w} ${y+h-rry}`,
          `A ${rrx} ${rry} 0 0 1 ${x+w-rrx} ${y+h}`,
          `L ${x+rrx} ${y+h}`,
          `A ${rrx} ${rry} 0 0 1 ${x} ${y+h-rry}`,
          `L ${x} ${y+rry}`,
          `A ${rrx} ${rry} 0 0 1 ${x+rrx} ${y}`,
          `Z`
        ].join(" ");
      }
      return `M ${x} ${y} L ${x+w} ${y} L ${x+w} ${y+h} L ${x} ${y+h} Z`;
    }

    if(tag === "circle"){
      const cx = Number(el.getAttribute("cx")||0);
      const cy = Number(el.getAttribute("cy")||0);
      const r  = Number(el.getAttribute("r")||0);
      if(!(r>0)) return "";
      return `M ${cx-r} ${cy} A ${r} ${r} 0 1 0 ${cx+r} ${cy} A ${r} ${r} 0 1 0 ${cx-r} ${cy} Z`;
    }

    if(tag === "ellipse"){
      const cx = Number(el.getAttribute("cx")||0);
      const cy = Number(el.getAttribute("cy")||0);
      const rx = Number(el.getAttribute("rx")||0);
      const ry = Number(el.getAttribute("ry")||0);
      if(!(rx>0 && ry>0)) return "";
      return `M ${cx-rx} ${cy} A ${rx} ${ry} 0 1 0 ${cx+rx} ${cy} A ${rx} ${ry} 0 1 0 ${cx-rx} ${cy} Z`;
    }

    return "";
  }

  function samplePathElement(pathEl){
    const L = pathEl.getTotalLength();
    if(!isFinite(L) || L <= 0) return null;

    const pts = [];
    for(let i=0;i<POINTS;i++){
      const p = pathEl.getPointAtLength((i/POINTS) * L);
      pts.push({x:p.x, y:p.y});
    }
    return pts;
  }

  // Load SVG and sample all visible paths/shapes with transforms + viewBox scaling
  const cache = {};
  async function loadShapeByName(name){
    const file = name.toLowerCase().trim().replace(/\s+/g,"-") + ".svg";
    if(cache[file]) return cache[file];

    try{
      const res = await fetch("shapes/" + file, {cache:"force-cache"});
      if(!res.ok) return null;

      const txt = await res.text();
      const doc = new DOMParser().parseFromString(txt, "image/svg+xml");
      const svgEl = doc.querySelector("svg");
      if(!svgEl) return null;

      // collect drawable elements
      const drawables = [
        ...svgEl.querySelectorAll("path, polygon, polyline, rect, circle, ellipse")
      ];
      if(!drawables.length) return null;

      // viewBox mapping: map SVG coordinates into our measurement group's local coords
      // We simulate the SVG's own viewport by scaling viewBox into a unit box, then sampling.
      // (If no viewBox, leave as-is.)
      const vb = parseViewBox(svgEl);

      clearMeasureGroup();

      // container group to apply viewBox normalization (so shapes behave same)
      const wrap = document.createElementNS("http://www.w3.org/2000/svg","g");
      measureGroup.appendChild(wrap);

      if(vb){
        // normalize to viewBox origin; no need to preserve exact pixel viewport
        wrap.setAttribute("transform", `translate(${-vb.minX} ${-vb.minY})`);
      }

      const sets = [];

      for(const el of drawables){
        const d = elementToPathData(el);
        if(!d) continue;

        const p = document.createElementNS("http://www.w3.org/2000/svg","path");
        p.setAttribute("d", d);

        // carry transform attributes from element and its parents (best-effort):
        // we only read the element's own "transform" (parent transforms are hard in DOMParser tree),
        // but many icon svgs store transform directly on the element.
        const tr = el.getAttribute("transform");
        if(tr) p.setAttribute("transform", tr);

        wrap.appendChild(p);

        const pts = samplePathElement(p);
        if(pts) sets.push(pts);
      }

      if(!sets.length) return null;

      // IMPORTANT: for better morph, reorder by angle for each set (single path or multi)
      const ordered = sets.map(s => reorderByAngleAndResample(s));

      // normalize size by AREA so Netherlands isn't tiny
      normalizeSizeAndCenterByArea(ordered);

      cache[file] = ordered;
      return ordered;
    } catch {
      return null;
    }
  }

  // --------------------------
  // Morph / render loop
  // --------------------------
  function render(){
    ensurePathEls(currentSets.length);

    for(let s=0; s<currentSets.length; s++){
      const pts = currentSets[s];

      // Loaded SVG shapes: poly => preserves silhouette (fixes "svg not same")
      // Blob/custom: smooth => satisfying look
      const d = (renderStyle === "poly") ? toPolyPath(pts) : toSmoothPath(pts);
      group.children[s].setAttribute("d", d);
    }

    if(isEditing) updateEditHandles();
  }

  function spawnFromTargets(targetSetsIn){
    const spawned = targetSetsIn.map((tset)=>{
      const base = (mode === "blob") ? blobPointsFromCtrl() : makeCirclePoints(BASE_R);
      const b = base.map(p => ({x:p.x,y:p.y}));

      const ct = centroid(tset);
      const cb = centroid(b);
      for(const p of b){
        p.x = (p.x - cb.x) + ct.x;
        p.y = (p.y - cb.y) + ct.y;
      }
      return b;
    });

    normalizeSizeAndCenterByArea(spawned);
    return spawned;
  }

  function beginMorph(nextSets, durationMs){
    if(currentSets.length !== nextSets.length){
      currentSets = spawnFromTargets(nextSets);
    }

    // Align each path index ordering to reduce twisting
    const aligned = nextSets.map((pts, idx) => {
      const cur = currentSets[idx];
      const t = pts.map(p => ({x:p.x, y:p.y}));
      return alignTargetToCurrent(cur, t);
    });

    normalizeSizeAndCenterByArea(currentSets);
    normalizeSizeAndCenterByArea(aligned);

    fromSets = deepCopySets(currentSets);
    toSets = deepCopySets(aligned);

    morphStart = performance.now();
    morphDur = durationMs;
    morphing = true;

    start();
  }

  let lastNow = performance.now();

  function tick(now){
    const dt = Math.min(0.033, (now - lastNow)/1000);
    lastNow = now;
    const t = now/1000;

    // procedural blob (always smooth)
    if(mode === "blob" && !morphing){
      updateBlob(dt, t);
      currentSets = [blobPointsFromCtrl()];
      renderStyle = "smooth";
      render();
      raf = requestAnimationFrame(tick);
      return;
    }

    if(morphing){
      const tt = Math.min(1, (now - morphStart) / morphDur);
      const e = easeInOutCubic(tt);

      const interp = fromSets.map((a, si) => {
        const b = toSets[si];
        const out = new Array(POINTS);
        for(let i=0;i<POINTS;i++){
          out[i] = { x: lerp(a[i].x, b[i].x, e), y: lerp(a[i].y, b[i].y, e) };
        }
        return out;
      });

      normalizeSizeAndCenterByArea(interp);
      currentSets = interp;

      if(tt >= 1){
        morphing = false;
        currentSets = deepCopySets(toSets);
        render();

        if(mode === "shape" && !isEditing){
          raf = null;
          return;
        }
      }
    }

    render();
    raf = requestAnimationFrame(tick);
  }

  function start(){
    if(raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(tick);
  }

  // --------------------------
  // Commands
  // --------------------------
  function isCssColor(str){
    const s = str.trim();
    if(!s) return false;
    const test = document.createElement("div");
    test.style.color = "";
    test.style.color = s;
    return !!test.style.color;
  }

  function exportSVGString(){
    const vb = "-220 -220 440 440";
    const ds = [...group.children].map(p => p.getAttribute("d") || "").filter(Boolean);
    const paths = ds.map(d => `    <path d="${d}" fill="${fillColor}"/>`).join("\n");
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${vb}">
  <g transform="rotate(${rotationDeg})">
${paths}
  </g>
</svg>\n`;
  }

  function doCopy(){
    navigator.clipboard.writeText(exportSVGString());
  }

  function doExport(){
    const text = exportSVGString();
    const blob = new Blob([text], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "shape.svg";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  async function applyShape(name){
    const v = name.trim();
    if(!v){
      exitEditMode();
      mode = "blob";
      currentShapeName = "";
      morphing = false;
      renderStyle = "smooth";
      start();
      return;
    }

    const sets = await loadShapeByName(v);
    if(!sets) return;

    exitEditMode();
    mode = "shape";
    currentShapeName = v.toLowerCase();

    // Loaded SVGs render in poly mode to preserve silhouette exactly
    renderStyle = "poly";

    beginMorph(sets, MORPH_MS_SHAPE);
  }

  function chooseRandomShapeNotCurrent(){
    if(SHAPES.length <= 1) return SHAPES[0] || "";
    const cur = currentShapeName;
    let pick = "";
    let tries = 0;
    do{
      pick = SHAPES[Math.floor(Math.random() * SHAPES.length)];
      tries++;
    }while(pick.toLowerCase() === cur && tries < 80);
    return pick;
  }

  cmd.addEventListener("keydown", async (e) => {
    if(e.key !== "Enter") return;

    const raw = cmd.value.trim();
    if(!raw){
      await applyShape("");
      return;
    }

    const lower = raw.toLowerCase();

    if(lower === "copy"){ doCopy(); return; }
    if(lower === "export"){ doExport(); return; }

    if(lower === "random"){
      const pick = chooseRandomShapeNotCurrent();
      if(pick) await applyShape(pick);
      return;
    }

    if(lower === "edit"){
      toggleEditMode();
      return;
    }

    if(lower.startsWith("rotate ")){
      const n = parseFloat(raw.slice(7).trim());
      if(Number.isFinite(n)) setRotation(rotationDeg + n);
      return;
    }

    if(isCssColor(raw)){
      setFill(raw);
      return;
    }

    await applyShape(raw);
  });

  // clearing returns to blob immediately
  cmd.addEventListener("input", async () => {
    if(cmd.value.trim() === ""){
      await applyShape("");
    }
  });

  // --------------------------
  // Info modal
  // --------------------------
  infoBtn.addEventListener("click", () => modal.classList.add("open"));
  closeBtn.addEventListener("click", () => modal.classList.remove("open"));
  modal.addEventListener("click", (e) => { if(e.target === modal) modal.classList.remove("open"); });
  window.addEventListener("keydown", (e) => { if(e.key === "Escape") modal.classList.remove("open"); });

  // =========================
  // EDIT MODE (drag points)
  // =========================
  let isEditing = false;
  let editCtrlPts = null;
  let draggingIndex = -1;

  function svgPointFromClient(clientX, clientY){
    const pt = svgRoot.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const ctm = svgRoot.getScreenCTM();
    if(!ctm) return {x:0,y:0};
    const inv = ctm.inverse();
    const p = pt.matrixTransform(inv);
    return {x:p.x, y:p.y};
  }

  function getSingleSetForEdit(){
    return currentSets[0].map(p => ({x:p.x,y:p.y}));
  }

  function initEditFromCurrent(){
    const pts = getSingleSetForEdit();
    editCtrlPts = [];
    for(let i=0;i<EDIT_CTRL;i++){
      const idx = Math.floor((i/EDIT_CTRL) * pts.length);
      editCtrlPts.push({x:pts[idx].x, y:pts[idx].y});
    }
    normalizeSizeAndCenterByArea([editCtrlPts]);
  }

  function rebuildFromEditCtrl(){
    // Build dense from edit ctrl using catmull-rom, then reorder by angle for consistent loop
    const dense = catmullRomClosed(editCtrlPts, POINTS);
    const ordered = reorderByAngleAndResample(dense);
    normalizeSizeAndCenterByArea([ordered]);

    currentSets = [ordered];
    mode = "shape";
    renderStyle = "smooth";      // custom should look satisfying
    currentShapeName = "custom";
    morphing = false;
    start();
  }

  function clearEditLayer(){
    while(editLayer.firstChild) editLayer.removeChild(editLayer.firstChild);
  }

  function buildEditHandles(){
    clearEditLayer();
    for(let i=0;i<EDIT_CTRL;i++){
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("class","handle");
      g.dataset.index = String(i);

      const o = document.createElementNS("http://www.w3.org/2000/svg","circle");
      o.setAttribute("r","8.5");
      o.setAttribute("class","handleOutline");
      g.appendChild(o);

      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("r","6");
      c.setAttribute("class","handleCore");
      g.appendChild(c);

      const r = document.createElementNS("http://www.w3.org/2000/svg","circle");
      r.setAttribute("r","10.5");
      r.setAttribute("class","handleRing");
      g.appendChild(r);

      editLayer.appendChild(g);
    }
    updateEditHandles();
  }

  function updateEditHandles(){
    if(!isEditing || !editCtrlPts) return;
    const nodes = [...editLayer.children];
    for(let i=0;i<nodes.length;i++){
      const p = editCtrlPts[i];
      nodes[i].setAttribute("transform", `translate(${fmt(p.x)} ${fmt(p.y)})`);
    }
  }

  function onPointerDown(e){
    const target = e.target.closest?.(".handle");
    if(!target) return;
    draggingIndex = Number(target.dataset.index);
    target.setPointerCapture?.(e.pointerId);
    e.preventDefault();
  }

  function onPointerMove(e){
    if(!isEditing || draggingIndex < 0) return;
    const p = svgPointFromClient(e.clientX, e.clientY);
    editCtrlPts[draggingIndex].x = p.x;
    editCtrlPts[draggingIndex].y = p.y;
    rebuildFromEditCtrl();
    e.preventDefault();
  }

  function onPointerUp(){
    draggingIndex = -1;
  }

  function enterEditMode(){
    if(isEditing) return;
    isEditing = true;
    document.body.classList.add("editing");

    // if blob, freeze snapshot first
    if(mode === "blob"){
      currentSets = [blobPointsFromCtrl()];
      mode = "shape";
      renderStyle = "smooth";
      currentShapeName = "custom";
      morphing = false;
    }

    initEditFromCurrent();
    buildEditHandles();

    svgRoot.addEventListener("pointerdown", onPointerDown);
    window.addEventListener("pointermove", onPointerMove, {passive:false});
    window.addEventListener("pointerup", onPointerUp);
    start();
  }

  function exitEditMode(){
    if(!isEditing) return;
    isEditing = false;
    document.body.classList.remove("editing");
    draggingIndex = -1;

    svgRoot.removeEventListener("pointerdown", onPointerDown);
    window.removeEventListener("pointermove", onPointerMove);
    window.removeEventListener("pointerup", onPointerUp);

    clearEditLayer();

    if(mode === "shape"){
      // stop the RAF if not morphing
      if(!morphing){
        if(raf) cancelAnimationFrame(raf);
        raf = null;
      }
    }
  }

  function toggleEditMode(){
    if(isEditing) exitEditMode();
    else enterEditMode();
  }

  // --------------------------
  // Boot
  // --------------------------
  setFill("#ffffff");
  setRotation(0);
  mode = "blob";
  renderStyle = "smooth";
  currentShapeName = "";
  start();
})();
</script>

</body>
</html>
